{
  "title": "OIDC & OIDC-AでMCPを保護する:「単なるAPI呼び出し」を超えたアイデンティティ対応APIゲートウェイ",
  "excerpt": "OpenID Connect(OIDC)と新しいOIDC-Aエージェント拡張をアイデンティティ対応APIゲートウェイと統合し、ユーザー、LLMエージェント、MCPツールを安全に認証する方法—基本的なAPIプロキシをはるかに超えて。",
  "content_html": "<p>AIエージェントは、研究デモから実際のエンタープライズアプリケーションへと急速に移行しており、大規模言語モデル(LLM)を企業データやサービスと接続しています。一般的なアプローチは、ツールやプラグインを使用してLLMがコンテキストを取得したりアクションを実行したりできるようにすることですが、これらを単なる「美化されたAPI呼び出し」として片付ける人もいます。実際には、AIをビジネスシステムと安全に統合することははるかに複雑です。ここで<strong>Model Context Protocol(MCP)</strong>が登場し、エンタープライズ規模のデプロイメントには<strong>OpenID Connect(OIDC)</strong>アイデンティティを備えた堅牢な<strong>プロキシアーキテクチャ</strong>が不可欠である理由があります。</p>\n\n<pre><code class=\"language-mermaid\">graph TB\n    User[ユーザー] --&gt; |対話| AIAgent[AIエージェント]\n    AIAgent --&gt; |MCPリクエスト| Proxy[APIゲートウェイ/プロキシ]\n    Proxy --&gt; |認証| OIDC[アイデンティティプロバイダー/OIDC]\n    Proxy --&gt; |ルーティング| Tools[MCPツール/サーバー]\n    Tools --&gt; |アクセス| Backend[バックエンドシステム]\n    \n    subgraph \"セキュリティ境界\"\n        Proxy\n        OIDC\n    end\n    \n    classDef security fill:#f96,stroke:#333,stroke-width:2px;\n    class Proxy,OIDC security;\n</code></pre>\n\n<p>上の図は、安全なMCP実装の高レベルアーキテクチャを示しています。このアーキテクチャの中核は、AIエージェントとMCPツールの間の中央セキュリティ制御ポイントとしてAPIゲートウェイ/プロキシを配置することです。プロキシは、OIDCをサポートするアイデンティティプロバイダーと連携して、認証、認可、アクセス制御を実施するセキュリティ境界を作成します。これにより、AIエージェントからのすべてのMCPリクエストが、実際のMCPツールに到達する前に適切に認証および認可されることが保証され、MCPツールは順番にさまざまなバックエンドシステムにアクセスします。</p>\n\n<p>MCPは、AIアシスタントが外部データソースやツールと対話するための一貫した方法を提供するオープン標準(元々はAnthropicによって導入)です。各システムに対する個別の統合の代わりに、MCPは普遍的なコネクタのように機能し、AIモデルが標準化されたJSON-RPCインターフェースを介してコンテキストを取得したりタスクを実行したりできるようにします。重要なことに、MCPは<strong>セキュリティを念頭に置いて構築されました</strong>—デフォルトではAIに何も公開されず、明示的に許可したものにのみアクセスできます。しかし実際には、多くのツールとユーザーにわたってその「許可リスト」原則を確保するには、慎重なインフラストラクチャが必要です。本番環境レベルの<strong>APIゲートウェイ(プロキシ)</strong>は、AIエージェント(MCPクライアント)とツールまたはデータソース(MCPサーバー)の間のゲートキーパーとして機能し、認証、認可、ルーティングルールを実施できます。</p>\n\n<p><em>ソリューションに入る前に、Envoyについて簡単に説明します:</em> MCPゲートウェイのリファレンス実装としてEnvoy Proxyを使用する提案が活発に行われています。EnvoyのリッチなL7ルーティングと拡張性により、強力な候補となっており、まもなくファーストクラスのMCPサポートが含まれる可能性があります。とはいえ、ここで説明するパターンは<strong>プロキシに依存しません</strong>—同様の機能を提供する最新のHTTPリバースプロキシまたはAPIゲートウェイ(Envoy、NGINX、HAProxy、Kongなど)を使用できます。目標は、Envoy設定の詳細ではなく、MCPの<em>安全なアーキテクチャ</em>を概説することです。</p>\n\n<h2>「美化されたAPI呼び出し」を超えて:安全なMCP統合の必要性</h2>\n\n<p>一見すると、MCPを介してAIツールを使用することは、Web APIを呼び出すのと同じくらい簡単に見えるかもしれません。基本的なデモでは、LLMエージェントがRESTエンドポイントにアクセスし、JSONを取得して、それで終わりです。しかし、実際のエンタープライズシナリオでは、舞台裏でもっと多くのことが起こっています:</p>\n\n<pre><code class=\"language-mermaid\">graph LR\n    subgraph \"シンプルなAPI呼び出し\"\n        A[クライアント] --&gt;|リクエスト| B[API]\n        B --&gt;|レスポンス| A\n    end\n    \n    subgraph \"エンタープライズMCPの現実\"\n        C[ユーザー] --&gt;|対話| D[AIエージェント]\n        D --&gt;|アイデンティティ付きMCPリクエスト| E[APIゲートウェイ]\n        E --&gt;|トークン検証| F[アイデンティティプロバイダー]\n        E --&gt;|リクエストルーティング| G[ツールレジストリ]\n        E --&gt;|認可されたリクエスト| H[MCPツール]\n        H --&gt;|ユーザーコンテキスト付きクエリ| I[バックエンドシステム]\n        I --&gt;|データ| H\n        H --&gt;|レスポンス| E\n        E --&gt;|フィルタリングされたレスポンス| D\n        D --&gt;|結果| C\n        \n        J[セキュリティ監視] -..-&gt;|監査| E\n    end\n    \n    classDef security fill:#f96,stroke:#333,stroke-width:2px;\n    class E,F,G,J security;\n</code></pre>\n\n<p>この図は、シンプルなAPI呼び出しとエンタープライズMCP実装の複雑な現実を対比しています。シンプルなケースでは、クライアントがAPIに直接リクエストを行い、レスポンスを受け取ります。しかし、エンタープライズMCPの現実では、フローははるかに複雑です:</p>\n\n<ol>\n<li>ユーザーがAIエージェントと対話する</li>\n<li>エージェントがユーザーのアイデンティティトークンを含むMCPリクエストを行う</li>\n<li>APIゲートウェイがアイデンティティプロバイダーでこのトークンを検証する</li>\n<li>ゲートウェイがツールレジストリに問い合わせてルーティングを決定する</li>\n<li>認可されている場合、リクエストは適切なMCPツールに転送される</li>\n<li>ツールがユーザーのコンテキストを使用してバックエンドシステムにクエリを実行する</li>\n<li>データがツールを通じてゲートウェイに戻る</li>\n<li>ゲートウェイがセキュリティポリシーに基づいてレスポンスをフィルタリングする可能性がある</li>\n<li>フィルタリングされたレスポンスがAIエージェントに到達する</li>\n<li>エージェントがユーザーに結果を提示する</li>\n</ol>\n\n<p>このプロセス全体を通じて、セキュリティ監視システムがゲートウェイレベルでのやり取りを監査します。この包括的なフローにより、ユーザーのアイデンティティ、権限、セキュリティポリシーがすべてのステップで実施され、シンプルなAPI呼び出しが伴うものをはるかに超えています。</p>\n\n<ul>\n<li><strong>ユーザーアイデンティティとアクセス制御:</strong> 対話型AIアプリケーション(内部システムにクエリを実行できるチャットアシスタントなど)では、各リクエストは特定の権限を持つユーザーから発信されます。システムは、AIが<em>現在のユーザー</em>が許可されているデータにのみアクセスするか、アクションを実行することを保証する必要があります。ユーザーがサービスに直接認証する典型的なAPI呼び出しとは異なり、ここではAIエージェントがユーザーに代わって呼び出しを行います。適切なアイデンティティ伝播メカニズムがなければ、シンプルなツール呼び出しが深刻なデータ漏洩や権限違反に変わるリスクがあります。</li>\n<li><strong>マルチステップコンテキスト交換:</strong> MCPはステートフルセッションとストリーミングインタラクションをサポートします。AIエージェントは、複数のツールを順番に呼び出し、その出力を統合して、マルチターンの会話を続ける可能性があります。これは一回限りのAPI呼び出しをはるかに超えています。このチェーンが長くなるほど、<strong>コンテキストポイズニング</strong>のようなことが起こる可能性が高くなります—あるステップからの誤ったまたは悪意のあるデータが後続のステップに影響を与える場合です。あるツールからの悪意のあるレスポンスがモデルを騙して次のステップで危険なことをさせないように、保護措置が必要です。</li>\n<li><strong>複雑な委任チェーン:</strong> 上記に関連して、ツールが他のツールを呼び出す場合を考えてみましょう。たとえば、AIが「ファイル検索」ツールを使用し、それ自体がデータベースにクエリを実行したり、別のAPIを呼び出したりする場合があります。この委任チェーンは、元のユーザーの権限とコンテキストを<strong>過度に権限を与えることなく</strong>転送する必要があります。各ホップは「誰が何をすることを許可されているか」の一貫した実施を必要とします。そうでなければ、中間サービスがユーザーが意図しなかったアクションを実行する可能性があります。これらの委任された認可を管理することは簡単ではありません。</li>\n<li><strong>動的ツールプロビジョニング:</strong> アジャイル環境では、新しいツール(MCPサーバー)が頻繁に追加されます—特定のデータセット用に新しいマイクロサービスを立ち上げてすぐにAIエージェントが利用できるようにしたり、サードパーティのプラグインをインストールできるようにしたりすることを考えてください。この動的性は柔軟性には優れていますが、セキュリティにとっては頭痛の種です。すべての新しいツールがセキュリティ基準を満たしていることをどのように保証しますか?未検証または悪意のあるツールが導入されるのをどのように防ぎますか?自由放任主義のアプローチは、すぐに混乱または侵害につながる可能性があります。ツールの<strong>オンボーディング、登録、ポリシー実施</strong>を明確に定義することが初日から必要です。</li>\n</ul>\n\n<p>要するに、エンタープライズは、AIツール統合を他の本番サービス統合と同じ厳密さで扱う必要があります—それ以上ではないにしても。<strong>適切なゲートウェイレイヤー</strong>は、中央制御ポイントとして機能することで、これらの懸念に対処するのに役立ちます。各AIエージェントまたはツールに信頼をハードコーディングする代わりに、プロキシは組織全体のセキュリティポリシーを課します。このアプローチは、<em>「単にAPIを呼び出す」という考え方を超えて</em>、すべてのMCP呼び出しが認証、認可、監視、監査される構造化されたモデルに移行します。</p>\n\n<h2>MCPワークフローにおける主要なセキュリティ課題</h2>\n\n<p>MCPを大規模に展開する際に発生するいくつかの特定のセキュリティ課題と、それらが重要である理由を見てみましょう:</p>\n\n<pre><code class=\"language-mermaid\">graph TD\n    A[コンテキストポイズニング] --&gt; |緩和| B[コンテンツフィルタリング]\n    A --&gt; |緩和| C[ツール検証]\n    \n    D[アイデンティティ伝播] --&gt; |解決| E[トークンベース認証]\n    D --&gt; |解決| F[委任チェーン]\n    \n    G[動的ツールプロビジョニング] --&gt; |管理| H[ツールレジストリ]\n    G --&gt; |管理| I[承認ワークフロー]\n    G --&gt; |管理| J[バージョン追跡]\n    \n    K[リモートMCP変更] --&gt; |制御| L[プロキシガバナンス]\n    \n    subgraph \"プロキシセキュリティ制御\"\n        B\n        C\n        E\n        F\n        H\n        I\n        J\n        L\n    end\n    \n    classDef challenge fill:#f66,stroke:#333,stroke-width:2px;\n    classDef solution fill:#6f6,stroke:#333,stroke-width:2px;\n    \n    class A,D,G,K challenge;\n    class B,C,E,F,H,I,J,L solution;\n</code></pre>\n\n<p>この図は、MCPワークフローにおける主要なセキュリティ課題(赤で表示)を、プロキシセキュリティ制御内で実装できる対応するソリューション(緑で表示)にマッピングしています。図は次のことを示しています:</p>\n\n<ul>\n<li>コンテキストポイズニングは、コンテンツフィルタリングとツール検証によって緩和される</li>\n<li>アイデンティティ伝播の課題は、トークンベース認証と適切な委任チェーンで解決される</li>\n<li>動的ツールプロビジョニングのリスクは、ツールレジストリ、承認ワークフロー、バージョン追跡を通じて管理される</li>\n<li>リモートMCP変更は、プロキシガバナンスを通じて制御される</li>\n</ul>\n\n<p>プロキシレイヤー内でこれらの制御を実装することにより、組織は各ツールまたはエージェントに対して個別に解決しようとするのではなく、これらのセキュリティ課題を一元化された一貫した方法で対処できます。</p>\n\n<ul>\n<li><strong>コンテキストポイズニング:</strong> MCPは外部データをモデルのコンテキストに供給できるため、データが意図的にモデルを誤解させたり悪用したりするように作成されるリスクがあります。これはプロンプトインジェクションの一形態である可能性があります—たとえば、ツールを介して取得されたドキュメントに、モデルの動作を乗っ取る指示が含まれている場合があります。悪意のある行為者は、有害なコンテンツや虚偽の情報を返すツールを登録しようとする可能性もあります。アーキテクチャには、ツールから来るコンテキストを検証およびサニタイズする方法が必要です。緩和策には、レスポンスのコンテンツフィルタリング、期待に対するデータの検証、または特定のクエリに対してモデルが信頼するツールの制限が含まれます。</li>\n<li><strong>委任チェーンとアイデンティティ伝播:</strong> 前述のように、AIエージェントはしばしばユーザーに代わって行動します。MCPサーバーを呼び出すとき、ユーザーが<em>誰であるか</em>(または少なくとも何をすることが許可されているか)を渡す必要があります。ツールがバックエンドAPIを呼び出す場合、そのバックエンドも資格情報を必要とする可能性があります。この委任のチェーンは厄介です—「パスワードの共有」アンチパターンを避けたり、キーをオープンにハードコーディングしたりしたくありません。代わりに、ソリューションにはトークンとOAuthフローが含まれます:たとえば、ユーザーが同意し、OAuth2/OIDCトークンが発行され、AIがMCPリクエストでそのトークンを運び、MCPサーバーがバックエンドAPIに<strong>それを渡す</strong>(または交換する)ことができます。これらのトークンを管理し、正しく使用されること(そして他の誰かによって使用されないこと)を保証することは、コアセキュリティタスクです。プロキシは、各ステップでアイデンティティコンテキストを添付および検証することでこれを促進する必要があります。また、<strong>RBACポリシー</strong>を有効にします—たとえば、ユーザーの役割が管理者である場合にのみ特定のツールメソッドを許可します。</li>\n</ul>\n\n<pre><code class=\"language-mermaid\">sequenceDiagram\n    participant User as ユーザー\n    participant AIAgent as AIエージェント\n    participant Proxy as APIゲートウェイ\n    participant IdP as アイデンティティプロバイダー\n    participant Tool as MCPツール\n    participant Backend as バックエンドシステム\n    \n    User-&gt;&gt;IdP: 1. 認証(ユーザー名/パスワード)\n    IdP-&gt;&gt;User: 2. OIDCトークン発行\n    User-&gt;&gt;AIAgent: 3. AIと対話(トークン添付)\n    AIAgent-&gt;&gt;Proxy: 4. トークン付きMCPリクエスト\n    Proxy-&gt;&gt;IdP: 5. トークン検証\n    IdP-&gt;&gt;Proxy: 6. トークン有効、クレーム/スコープ含む\n    \n    alt トークン有効で必要な権限あり\n        Proxy-&gt;&gt;Tool: 7. ユーザーコンテキスト付きリクエスト転送\n        Tool-&gt;&gt;Backend: 8. 委任認証でクエリ\n        Backend-&gt;&gt;Tool: 9. データ返却(ユーザー権限でフィルタリング)\n        Tool-&gt;&gt;Proxy: 10. 結果返却\n        Proxy-&gt;&gt;AIAgent: 11. 認可されたレスポンス返却\n        AIAgent-&gt;&gt;User: 12. 結果提示\n    else トークン無効または権限不足\n        Proxy-&gt;&gt;AIAgent: 7. リクエスト拒否(401/403)\n        AIAgent-&gt;&gt;User: 8. アクセス拒否報告\n    end\n</code></pre>\n\n<p>このシーケンス図は、OIDCを使用したMCPシステムにおける認証と認可のフローを示しています。プロセスは、ユーザーがアイデンティティプロバイダーに認証し、OIDCトークンを受け取ることから始まります。このトークンは、ユーザーのAIエージェントとのやり取りに添付されます。エージェントがMCPリクエストを行うと、このトークンが含まれ、APIゲートウェイがアイデンティティプロバイダーでそれを検証します。</p>\n\n<p>トークンが有効で必要な権限(クレーム/スコープ)を含んでいる場合、リクエストはユーザーのコンテキストとともに適切なMCPツールに転送されます。ツールは委任認証を使用してバックエンドシステムにクエリを実行でき、返されるデータがユーザーの権限に従ってフィルタリングされることを保証します。結果はシステムを通じてユーザーに戻ります。</p>\n\n<p>トークンが無効であるか、十分な権限がない場合、リクエストはゲートウェイレベルで適切なエラーコード(401 Unauthorizedまたは403 Forbidden)で拒否され、AIエージェントはこのアクセス拒否をユーザーに報告します。</p>\n\n<p>このフローにより、ユーザーのアイデンティティと権限が、機密データや操作への不正アクセスを防ぎながら、やり取りチェーン全体を通じて一貫して実施されることが保証されます。</p>\n\n<ul>\n<li><strong>動的ツールプロビジョニング:</strong> MCPエコシステムでは、ツールが出入りする可能性があります。たとえば、エンタープライズは特定のデータセット用に新しいMCPサーバーを迅速に立ち上げたり、MCP経由でサードパーティサービスを統合したりする可能性があります。制御がなければ、AIエージェントは新しいツールが表示されるとすぐに呼び出しを開始する可能性があります。それはリスクがあります—新しく追加されたツールをデフォルトですべての人が利用できるようにしたくない場合や、検証が必要な場合があります。設定の側面もあります:新しいツールエンドポイントはAIによって発見可能である必要があり、ゲートウェイはそれらへのルーティング方法と必要な認証を知る必要があります。安全なセットアップには、プロキシが参照する<strong>ツールレジストリ</strong>または検出サービス、およびツールの管理承認が含まれる可能性があります。プロキシは、各エージェント開発者がロジックを更新することに依存するのではなく、各新しいツールに対して適切な認証とルーティングを自動的に実施できます。これにより、ツールのライフサイクルのガバナンスレイヤーが提供されます。</li>\n</ul>\n\n<pre><code class=\"language-mermaid\">sequenceDiagram\n    participant Admin as 管理者\n    participant Registry as ツールレジストリ\n    participant Proxy as APIゲートウェイ\n    participant Tool as 新しいMCPツール\n    participant AIAgent as AIエージェント\n    \n    Admin-&gt;&gt;Tool: 1. 新しいMCPツール開発\n    Admin-&gt;&gt;Registry: 2. ツール登録(メタデータ、エンドポイント、認証要件)\n    Registry-&gt;&gt;Registry: 3. ツール設定検証\n    Registry-&gt;&gt;Proxy: 4. ルーティング設定更新\n    \n    Note over Registry,Proxy: ツールは登録されたが、まだ承認されていない\n    \n    Admin-&gt;&gt;Registry: 5. 特定のユーザーグループに対してツール承認\n    Registry-&gt;&gt;Proxy: 6. アクセスポリシー更新\n    \n    Note over AIAgent,Proxy: ツールは認可されたユーザーが利用可能になった\n    \n    AIAgent-&gt;&gt;Proxy: 7. 利用可能なツールを発見\n    Proxy-&gt;&gt;AIAgent: 8. ユーザーに承認されたツールを返却\n    AIAgent-&gt;&gt;Proxy: 9. 新しいツールを呼び出し\n    Proxy-&gt;&gt;Tool: 10. 認可されている場合、リクエストをルーティング\n</code></pre>\n\n<p>このシーケンス図は、安全なMCP環境におけるツール登録と承認ワークフローを示しています。プロセスは、管理者が新しいMCPツールを開発し、メタデータ、エンドポイント、認証要件を提供してツールレジストリに登録することから始まります。レジストリはツール設定を検証し、APIゲートウェイのルーティング設定を更新します。</p>\n\n<p>この時点で、ツールは登録されていますが、まだ使用が承認されていません。管理者は特定のユーザーグループに対してツールを明示的に承認する必要があり、これによりAPIゲートウェイのアクセスポリシーの更新がトリガーされます。その後初めて、ツールが認可されたユーザーに利用可能になります。</p>\n\n<p>AIエージェントがプロキシを通じて利用可能なツールを発見すると、現在のユーザーに対して承認されたツールに関する情報のみを受け取ります。エージェントが新しいツールを呼び出すと、プロキシはユーザーがそれにアクセスすることを認可されている場合にのみ、リクエストをツールにルーティングします。</p>\n\n<p>このワークフローにより、新しいツールが使用される前に適切な検証と承認を受けることが保証され、アクセスが認可されたユーザーのみに制限されます。また、ツールガバナンスプロセスを一元化し、安全な方法でMCPツールのライフサイクルを管理しやすくします。</p>\n\n<p>これらの課題を認識することで、セキュリティエンジニアとアーキテクトは問題が発生する<em>前に</em>防御を設計できます。次に、アイデンティティ対応プロキシがクリーンで一元化された方法でこれらの防御を提供する方法を見ていきます。</p>\n\n<h2>MCPのためのアイデンティティ対応プロキシパターン</h2>\n\n<p>クラウドアーキテクチャで実証されている設計は、サービスの前に<strong>リバースプロキシ</strong>(しばしばAPIゲートウェイと呼ばれる)を配置することです。MCPベースのAIシステムも例外ではありません。AIエージェント(クライアント)とMCPサーバー(ツール/バックエンド)の間にインテリジェントなプロキシを導入することで、すべてのAIツールトラフィックが通過する制御されたファネルを作成します。このプロキシはレイヤー7(アプリケーション層)で動作できます。つまり、HTTPやJSONペイロードさえも理解し、きめ細かい制御を可能にします。以下では、このようなプロキシがMCPのセキュリティ保護において果たす主要な役割を概説します:</p>\n\n<pre><code class=\"language-mermaid\">graph TB\n    subgraph \"クライアント側\"\n        User[ユーザー]\n        AIAgent[AIエージェント]\n        User --&gt;|対話| AIAgent\n    end\n    \n    subgraph \"セキュリティレイヤー\"\n        Proxy[APIゲートウェイ/プロキシ]\n        Auth[認証]\n        RBAC[認可/RBAC]\n        Registry[ツールレジストリ]\n        Audit[監査ログ]\n        \n        Proxy --&gt;|使用| Auth\n        Proxy --&gt;|実施| RBAC\n        Proxy --&gt;|参照| Registry\n        Proxy --&gt;|生成| Audit\n    end\n    \n    subgraph \"MCPツール\"\n        Tool1[ドキュメント検索]\n        Tool2[データベースクエリ]\n        Tool3[ファイル操作]\n        Tool4[外部API]\n    end\n    \n    subgraph \"バックエンドシステム\"\n        DB[(データベース)]\n        Storage[ファイルストレージ]\n        APIs[内部API]\n        External[外部サービス]\n    end\n    \n    AIAgent --&gt;|MCPリクエスト| Proxy\n    Proxy --&gt;|ルーティング| Tool1\n    Proxy --&gt;|ルーティング| Tool2\n    Proxy --&gt;|ルーティング| Tool3\n    Proxy --&gt;|ルーティング| Tool4\n    \n    Tool1 --&gt;|読み取り| DB\n    Tool1 --&gt;|読み取り| Storage\n    Tool2 --&gt;|クエリ| DB\n    Tool3 --&gt;|管理| Storage\n    Tool4 --&gt;|呼び出し| APIs\n    Tool4 --&gt;|呼び出し| External\n    \n    classDef security fill:#f96,stroke:#333,stroke-width:2px;\n    class Proxy,Auth,RBAC,Registry,Audit security;\n</code></pre>\n\n<p>この図は、MCPのためのアイデンティティ対応プロキシパターンの詳細なビューを提供します。アーキテクチャは4つの主要なレイヤーに分かれています:</p>\n\n<ol>\n<li><strong>クライアント側</strong>:ユーザーがAIエージェントと対話し、MCPリクエストを生成します。</li>\n<li><strong>セキュリティレイヤー</strong>:APIゲートウェイ/プロキシがセキュリティレイヤーの中心に位置し、認証、認可/RBAC、ツールレジストリ、監査ログコンポーネントと連携してセキュリティポリシーを実施します。</li>\n<li><strong>MCPツール</strong>:ドキュメント検索、データベースクエリ、ファイル操作、外部APIアクセスなど、MCPインターフェースを通じて利用可能なさまざまなツール。</li>\n<li><strong>バックエンドシステム</strong>:MCPツールが対話する実際のデータソースとサービス。データベース、ファイルストレージ、内部API、外部サービスが含まれます。</li>\n</ol>\n\n<p>AIエージェントからのすべてのMCPリクエストはプロキシを通過する必要があり、プロキシはリクエストを認証し、RBACポリシーを実施し、ツールレジストリに問い合わせてルーティングを決定し、監査ログを生成します。プロキシは認可されたリクエストを適切なMCPツールにルーティングし、ツールは順番にバックエンドシステムと対話します。</p>\n\n<p>この一元化されたセキュリティアーキテクチャにより、使用されているツールやアクセスされているバックエンドシステムに関係なく、すべてのMCPインタラクションにわたってセキュリティポリシーの一貫した実施が保証されます。</p>\n\n<h3>セッション対応ルーティングとロードバランシング</h3>\n\n<p>シンプルなステートレスAPI呼び出しとは異なり、MCPセッションは長期間にわたり、ストリーミング(出力用のServer-Sent Eventsなど)を含む可能性があります。プロキシは、特定のセッションまたは会話に属するすべてのリクエストとレスポンスが一貫して処理されることを保証する必要があります。これはしばしば<strong>セッションアフィニティ</strong>の実装を意味します—MCPサーバーの複数のインスタンスが実行されている場合、プロキシは特定のセッションのトラフィックを毎回同じインスタンスにルーティングします。これにより、たとえばツールAの状態(インメモリキャッシュ、コンテキストウィンドウなど)がリクエスト2がリクエスト1とは異なるインスタンスに行ったために失われるという問題を防ぎます。最新のプロキシは、HTTPヘッダーまたはルートを使用してセッション対応ロードバランシングを実行できます(たとえば、URLのセッションIDまたはクライアントIDを特定のバックエンドにマッピング)。さらに、プロキシはSSE接続を適切に処理できるため、ストリーミングレスポンスがネットワーク仲介者によって誤って壊されることはありません。セッションを再開または引き継ぐ必要がある場合、ゲートウェイはそれを調整できます(MCP用の今後のEnvoy機能で提案されているように)。要するに、プロキシはMCPのステートフルなやり取りの信頼性と一貫性を保証し、これはユーザーエクスペリエンスと正しいコンテキストの維持にとって重要です。</p>\n\n<pre><code class=\"language-mermaid\">sequenceDiagram\n    participant User as ユーザー\n    participant AIAgent as AIエージェント\n    participant Proxy as APIゲートウェイ\n    participant Instance1 as ツールインスタンス1\n    participant Instance2 as ツールインスタンス2\n    \n    User-&gt;&gt;AIAgent: 会話開始\n    AIAgent-&gt;&gt;Proxy: MCPリクエスト1(session=abc123)\n    \n    Note over Proxy: セッションアフィニティルーティング\n    \n    Proxy-&gt;&gt;Instance1: インスタンス1にルーティング\n    Instance1-&gt;&gt;Proxy: 状態付きレスポンス\n    Proxy-&gt;&gt;AIAgent: レスポンス返却\n    \n    User-&gt;&gt;AIAgent: 会話継続\n    AIAgent-&gt;&gt;Proxy: MCPリクエスト2(session=abc123)\n    \n    Note over Proxy: 同じセッションIDは同じインスタンスにルーティング\n    \n    Proxy-&gt;&gt;Instance1: インスタンス1にルーティング(状態保持)\n    Instance1-&gt;&gt;Proxy: 更新された状態付きレスポンス\n    Proxy-&gt;&gt;AIAgent: レスポンス返却\n    \n    Note over User,Instance2: セッションアフィニティがないと、リクエストがインスタンス2に行き、状態が失われる可能性がある\n</code></pre>\n\n<p>このシーケンス図は、MCP環境でセッションアフィニティがどのように機能するかを示しています。ユーザーがAIエージェントとの会話を開始すると、エージェントはセッション識別子(この場合は「abc123」)を含むMCPリクエストをAPIゲートウェイに送信します。ゲートウェイはこのセッションIDを使用して、リクエストを特定のツールインスタンス(インスタンス1)にルーティングします。</p>\n\n<p>ユーザーが会話を続けると、エージェントは同じセッションIDで別のMCPリクエストを行います。ゲートウェイがセッションアフィニティを実装しているため、このリクエストを同じインスタンス(インスタンス1)にルーティングし、前のやり取りからの状態を保持します。これにより、ユーザーに一貫性のある首尾一貫したエクスペリエンスが保証されます。</p>\n\n<p>セッションアフィニティがないと、2番目のリクエストが別のインスタンス(インスタンス2)にルーティングされる可能性があり、最初のリクエストからの状態情報がありません。これにより、ツールが前のやり取りのコンテキストを持たないため、壊れたエクスペリエンスになります。</p>\n\n<p>セッションアフィニティは、多くのAIインタラクションがステートフルでコンテキスト依存であるため、MCPにとって特に重要です。プロキシがこのセッションの一貫性を維持する能力は、よりシンプルなAPI統合アプローチに対する重要な利点です。</p>\n\n<h3>認証のためのJWTとOIDC統合</h3>\n\n<p>MCPゲートウェイに到達するすべてのリクエストは、有効なアイデンティティトークン—通常、OIDCを介してアイデンティティプロバイダーによって発行されたJSON Web Token(JWT)—を運ぶ必要があります。JWTを要求することで、プロキシはツール自体から認証をオフロードし、認証され認可された呼び出しのみが通過することを保証します。実際には、これはAIエージェント(またはエージェントとのユーザーのセッション)がOIDCトークン(たとえば、IDトークンまたはアクセストークン)を取得し、各MCPリクエストに添付する必要があることを意味します(多くの場合、<code>Authorization: Bearer &lt;token&gt;</code>のようなHTTPヘッダーで)。プロキシはこのトークンを検証し、署名とクレーム(発行者、オーディエンス、有効期限など)をチェックし、適切に認証されていないリクエストを拒否します。このようにして、MCPサーバーは匿名の呼び出しを見ることはありません—ゲートウェイがアイデンティティを検証したことを信頼します。</p>\n\n<pre><code class=\"language-mermaid\">sequenceDiagram\n    participant User as ユーザー\n    participant App as AIアプリケーション\n    participant IdP as アイデンティティプロバイダー\n    participant Proxy as APIゲートウェイ\n    participant Tool as MCPツール\n    \n    User-&gt;&gt;App: AIアプリケーションにアクセス\n    App-&gt;&gt;IdP: ログインにリダイレクト\n    User-&gt;&gt;IdP: 認証\n    IdP-&gt;&gt;App: 認可コード\n    App-&gt;&gt;IdP: トークンのコード交換\n    IdP-&gt;&gt;App: IDトークン + アクセストークン\n    \n    Note over App: トークンを安全に保存\n    \n    User-&gt;&gt;App: AIツールを使用してリクエスト\n    App-&gt;&gt;Proxy: アクセストークン付きMCPリクエスト\n    \n    Proxy-&gt;&gt;Proxy: トークン検証(署名、有効期限、オーディエンス)\n    Proxy-&gt;&gt;Proxy: ユーザーアイデンティティと権限を抽出\n    \n    alt トークン有効\n        Proxy-&gt;&gt;Tool: ユーザーコンテキスト付きリクエスト転送\n        Tool-&gt;&gt;Proxy: レスポンス\n        Proxy-&gt;&gt;App: レスポンス返却\n        App-&gt;&gt;User: 結果表示\n    else トークン無効\n        Proxy-&gt;&gt;App: 401 Unauthorized\n        App-&gt;&gt;User: セッション期限切れ、再度ログインしてください\n    end\n    \n    Note over App,Proxy: トークンリフレッシュはバックグラウンドで発生\n    App-&gt;&gt;IdP: 必要に応じてトークンをリフレッシュ\n    IdP-&gt;&gt;App: 新しいアクセストークン\n</code></pre>\n\n<p>このシーケンス図は、MCP環境におけるOIDC認証フローを示しています。プロセスは、ユーザーがAIアプリケーションにアクセスすると開始され、アプリケーションは認証のためにアイデンティティプロバイダーにリダイレクトします。ユーザーが認証すると、アイデンティティプロバイダーは認可コードを発行し、アプリケーションはそれをIDトークンとアクセストークンと交換します。</p>\n\n<p>アプリケーションはこれらのトークンを安全に保存し、AIエージェントを通じてMCPリクエストを行うときにアクセストークンを使用します。プロキシがリクエストを受信すると、署名、有効期限、オーディエンス、その他のクレームをチェックしてトークンを検証します。また、トークンからユーザーのアイデンティティと権限を抽出します。</p>\n\n<p>トークンが有効な場合、プロキシはユーザーのコンテキストとともに適切なMCPツールにリクエストを転送します。ツールはリクエストを処理してレスポンスを返し、プロキシを通じてアプリケーションに、最終的にユーザーに流れます。</p>\n\n<p>トークンが無効(期限切れ、改ざんなど)の場合、プロキシは401 Unauthorizedレスポンスを返し、アプリケーションはユーザーに再度ログインするよう促します。</p>\n\n<p>バックグラウンドでは、アプリケーションはリフレッシュトークンを使用して、ユーザーに再認証を要求することなく、必要に応じて新しいアクセストークンを取得できます。これにより、セキュリティを維持しながらスムーズなユーザーエクスペリエンスが保証されます。</p>\n\n<p>このOIDC統合は、エンタープライズ環境で広く採用されている堅牢な認証メカニズムを提供し、既存のアイデンティティ管理システムとうまく統合されます。</p>\n\n<h3>エージェントとツールアイデンティティのためのOIDC-Aの導入</h3>\n\n<p>上記の議論は<strong>人間のユーザー</strong>の認証に焦点を当てていますが、本番環境レベルのMCPデプロイメントでは、さらに2つのアクターを識別する必要があります:</p>\n\n<ol>\n<li>ワークフローを調整している<em>LLMエージェント</em>。</li>\n<li>バックエンドで呼び出されている<em>MCPツール/リソース</em>。</li>\n</ol>\n\n<p>私たちの関連記事「<strong>OpenID Connect for Agents(OIDC-A)1.0提案</strong>」({{ site.baseurl }}/2025/04/28/oidc-a-proposal/)は、OIDC Core 1.0を<strong>エージェントアイデンティティ、証明、委任チェーン</strong>のための豊富なクレームセットで拡張しています。実際には、これは次のことを意味します:</p>\n\n<ul>\n<li>AIエージェントがセッションを開始すると、OIDC-Aクレーム(<code>agent_type</code>、<code>agent_model</code>、<code>agent_instance_id</code>、<code>delegator_sub</code>、<code>delegation_chain</code>など)を含む<strong>IDトークン</strong>を取得します。このトークンは、すべてのMCPリクエストでユーザーのアクセストークンと一緒に移動します。</li>\n<li>MCPツールも同様に、ツールの機能、バージョン、信頼レベル(<code>agent_capabilities</code>、<code>agent_trust_level</code>、<code>agent_attestation</code>)などのメタデータを宣伝する独自のOIDCアイデンティティを公開できます(または署名された<em>リソーストークン</em>を発行されます)。</li>\n<li>ゲートウェイは、すべての呼び出しで最大<strong>3つ</strong>のアイデンティティ—<strong>ユーザー→エージェント→ツール</strong>—を検証し、RBACおよびコンプライアンスポリシーに対して評価できる明示的な<em>委任チェーン</em>を形成します。</li>\n</ul>\n\n<p>OIDC-Aを採用すると、いくつかの利点があります:</p>\n\n<ul>\n<li>リクエストパスに触れるすべてのもののエンドツーエンドで暗号的に検証可能なアイデンティティ。</li>\n<li>エージェントまたはツールの機能に基づくきめ細かい認可(たとえば、<code>email:draft</code>機能を宣伝するエージェントのみがMailツールを呼び出すことを許可)。</li>\n<li>組み込みの証明(<code>agent_attestation</code>)により、ゲートウェイはトラフィックをルーティングする前に、エージェントとツールの両方の整合性と出所を検証できます。</li>\n</ul>\n\n<p>この記事の残りの部分では、ゲートウェイによって検証される「トークン」に言及するときはいつでも、これが<strong>ユーザーのトークン、エージェントのOIDC-Aトークン、および(オプションで)ツール/リソーストークン</strong>を含むと仮定してください—すべてが単一のポリシー決定ステップで評価されます。</p>\n\n<p>このパターンは、APIセキュリティで既に広く使用されています:<em>「APIゲートウェイは、アプリケーション自体に負担をかけることなく、認証を安全かつ一貫して実装できます。」</em>私たちのコンテキストでは、MCPプロキシはOIDC経由でエンタープライズSSO(Azure AD、Oktaなど)と統合して、ユーザーログインフローとトークン検証を処理する可能性があります。多くのゲートウェイはOIDCをネイティブにサポートし、必要に応じてユーザーログインのリダイレクトを開始し、結果のトークンをセッション継続のためにCookieに保存します。ヘッドレスエージェントシナリオ(AIがサーバー間でツールを呼び出している場合)では、トークンは帯域外でプロビジョニングされる可能性があります(たとえば、ユーザーがAIアプリにログインしたため、アプリがエージェントが使用するトークンを注入します)。いずれにせよ、ゲートウェイは<strong>トークンなし=アクセスなし</strong>を実施します。また、トークンクレームを役割またはスコープにマッピングして認可を実装することもできます(たとえば、「HR_read」スコープを持つユーザーのみが「HRデータベース」ツールを使用できます)。これは、MCPの安全な接続の設計目標と完全に一致します—MCPをOIDCおよびOIDC-Aと組み合わせることで、ツール使用のためのエンドツーエンドの認証されたチャネルが得られます。</p>\n\n<pre><code class=\"language-mermaid\">sequenceDiagram\n    participant User as ユーザー\n    participant Agent as LLMエージェント(OIDC-A)\n    participant Proxy as APIゲートウェイ\n    participant Tool as MCPツール(OIDC-A)\n    participant Backend as バックエンドシステム\n\n    User-&gt;&gt;Agent: 1. 対話(チャット、フォームなど)\n    Agent-&gt;&gt;Proxy: 2. MCPリクエスト\\nBearerユーザートークン + エージェントOIDC-Aトークン\n    Proxy-&gt;&gt;Proxy: 3. ユーザートークン(OIDC) &amp; エージェントトークン(OIDC-A)を検証\n    Proxy--&gt;&gt;Tool: 4. ツールのオプションの*リソーストークン*付きリクエスト転送\n    Tool-&gt;&gt;Backend: 5. 委任認証を使用してクエリ/アクション\n    Backend--&gt;&gt;Tool: 6. データ/結果\n    Tool--&gt;&gt;Proxy: 7. レスポンス(証明を含む可能性あり)\n    Proxy--&gt;&gt;Agent: 8. 認可されたレスポンス\n    Agent--&gt;&gt;User: 9. 結果提示\n</code></pre>\n\n<h3>ツールメタデータフィルタリングとポリシー実施</h3>\n\n<p>プロキシの強力な利点は、URLだけでなく、リクエスト内の<em>メタデータ</em>に基づいてルーティング決定を行えることです。MCPでは、リクエストとレスポンスはJSON-RPC形式であり、ツールメソッド名、パラメータ、さらにはツールアノテーションなどのフィールドが含まれます。アイデンティティ対応プロキシは、これらの詳細を検査し、<strong>ポリシールール</strong>を適用するように設定できます。たとえば、次のようなルールを設定できます:</p>\n\n<pre><code class=\"language-mermaid\">graph TD\n    subgraph \"MCPリクエスト\"\n        Request[JSON-RPCリクエスト]\n        Method[ツールメソッド]\n        Params[パラメータ]\n        User[ユーザーアイデンティティ]\n    end\n    \n    subgraph \"ポリシーエンジン\"\n        Rules[ポリシールール]\n        RBAC[ロールベースアクセス]\n        Audit[監査ログ]\n        Transform[レスポンス変換]\n    end\n    \n    Request --&gt; Method\n    Request --&gt; Params\n    Request --&gt; User\n    \n    Method --&gt; Rules\n    Params --&gt; Rules\n    User --&gt; RBAC\n    \n    Rules --&gt; Decision{許可/拒否}\n    RBAC --&gt; Decision\n    \n    Decision --&gt;|許可| Forward[ツールに転送]\n    Decision --&gt;|拒否| Reject[リクエスト拒否]\n    \n    Forward --&gt; Audit\n    Reject --&gt; Audit\n    \n    Forward --&gt; Tool[MCPツール]\n    Tool --&gt; Response[ツールレスポンス]\n    Response --&gt; Transform\n    Transform --&gt; Filtered[フィルタリングされたレスポンス]\n    \n    classDef request fill:#bbf,stroke:#333,stroke-width:1px;\n    classDef policy fill:#fbf,stroke:#333,stroke-width:1px;\n    classDef action fill:#bfb,stroke:#333,stroke-width:1px;\n    \n    class Request,Method,Params,User request;\n    class Rules,RBAC,Audit,Transform policy;\n    class Decision,Forward,Reject,Filtered action;\n</code></pre>\n\n<p>この図は、MCPプロキシでツールメタデータフィルタリングとポリシー実施がどのように機能するかを示しています。プロセスは、ツールメソッド、パラメータ、ユーザーアイデンティティ情報を含むJSON-RPC形式のMCPリクエストから始まります。これらのコンポーネントが抽出され、ポリシーエンジンに供給されます。</p>\n\n<p>ポリシーエンジンは、ポリシールール、ロールベースアクセス制御(RBAC)、監査ログ、レスポンス変換コンポーネントで構成されています。ツールメソッドとパラメータはポリシールールに対して評価され、ユーザーアイデンティティはRBAC権限に対してチェックされます。</p>\n\n<p>これらの評価に基づいて、ポリシーエンジンは許可/拒否の決定を行います。リクエストが許可されている場合、MCPツールに転送されます。拒否されている場合は拒否されます。いずれの場合も、アクションは監査目的でログに記録されます。</p>\n\n<p>リクエストが許可されてツールによって処理されると、レスポンスはクライアントに返される前に変換ステップを通過する可能性があります。この変換は、ユーザーが見るべきでない機密情報を削除するなど、セキュリティポリシーに基づいてレスポンスをフィルタリングまたは変更できます。</p>\n\n<p>メタデータレベルでのこのきめ細かいポリシー実施により、シンプルなURLベースのルーティングをはるかに超える洗練されたセキュリティ制御が可能になります。たとえば:</p>\n\n<ul>\n<li><em>「ツール呼び出しが<code>delete_file</code>で、ユーザーがIT管理者グループにいない場合、リクエストを拒否します。」</em></li>\n<li><em>「平日の午前9時から午後5時の間のみ<code>execute_sql</code>ツールを許可し、すべてのクエリをログに記録します。」</em></li>\n<li><em>「ツールが機密データを含むとマークされている場合、レスポンスがサニタイズまたは暗号化されていることを確認します。」</em></li>\n</ul>\n\n<p>これは、Webアプリケーションファイアウォール(WAF)またはAPIゲートウェイがコンテンツフィルタリングを実行することに類似していますが、AIツールの使用に合わせて調整されています。Envoy MCP提案では、これはMCPメッセージを解析し、それらにRBACフィルターを使用することに対応します。プロキシは本質的に各ツール呼び出しの<em>意図</em>を理解し、適切にゲートできます。また、必要に応じてデータを編集または変換することもできます—たとえば、ユーザーが見るべきでないレスポンスから特定のフィールドを削除したり、個人を特定できる情報をマスキングしたりします。これをゲートウェイで一元化することで、各ツールサービスでチェックを実装する必要がなくなります(一貫性がなかったり忘れられたりする可能性があります)。<strong>監査</strong>も別の利点です:プロキシは、ユーザーアイデンティティとパラメータとともにすべてのツール呼び出しをログに記録し、監視のためにSIEMシステムに供給できます。そうすれば、AIがいつか本来すべきでないことをした場合、どのツール呼び出しが関与し、誰がそれを促したかの明確な証跡があります。要するに、メタデータベースのフィルタリングは、プロキシをスマートなポリシー実施ポイントに変え、MCPの基本機能の上に安全層を追加します。</p>\n\n<h3>バージョン対応およびコンテキスト対応ルーティング</h3>\n\n<p>エンタープライズは常にサービスを進化させています—新しいバージョン、A/Bテスト、ステージング対本番デプロイメントなど。プロキシは、AIエージェントがこれらの変更を処理する方法を大幅に簡素化できます。AIがどのバージョンのツールを呼び出すかを知る必要がある代わりに、ゲートウェイは<strong>バージョン対応ルーティング</strong>を実装できます。たとえば、「ドキュメント検索」ツールのMCPエンドポイントはエージェントにとって同じままですが、プロキシはリクエストの90%をサービスのv1に、10%を新しいv2にルーティングする可能性があります(カナリアロールアウトの場合)。または、内部ユーザーを「ベータ」インスタンスにルーティングし、外部ユーザーを安定版にルーティングします。これは、リクエスト属性に一致させるか、ユーザーオーディエンスとツール識別子を含むルーティングルールを使用して行われます。</p>\n\n<pre><code class=\"language-mermaid\">graph TB\n    AIAgent[AIエージェント] --&gt;|MCPリクエスト| Proxy[APIゲートウェイ]\n    \n    Proxy --&gt;|\"90%トラフィック\"| V1[ツールv1]\n    Proxy --&gt;|\"10%トラフィック\"| V2[ツールv2 - カナリア]\n    \n    Proxy --&gt;|\"内部ユーザー\"| Beta[ベータバージョン]\n    Proxy --&gt;|\"外部ユーザー\"| Stable[安定バージョン]\n    \n    Proxy --&gt;|\"小さいリクエスト\"| Standard[標準インスタンス]\n    Proxy --&gt;|\"大きいリクエスト\"| HighMem[高メモリインスタンス]\n    \n    Proxy --&gt;|\"米国ユーザー\"| US[米国リージョン]\n    Proxy --&gt;|\"EUユーザー\"| EU[EUリージョン]\n    \n    classDef proxy fill:#f96,stroke:#333,stroke-width:2px;\n    classDef version fill:#bbf,stroke:#333,stroke-width:1px;\n    classDef audience fill:#bfb,stroke:#333,stroke-width:1px;\n    classDef size fill:#fbf,stroke:#333,stroke-width:1px;\n    classDef region fill:#ff9,stroke:#333,stroke-width:1px;\n    \n    class Proxy proxy;\n    class V1,V2 version;\n    class Beta,Stable audience;\n    class Standard,HighMem size;\n    class US,EU region;\n</code></pre>\n\n<p>この図は、APIゲートウェイがMCPリクエストに対して実装できるさまざまなルーティング戦略を示しています。ゲートウェイは複数の要因に基づいてトラフィックをルーティングできます:</p>\n\n<ol>\n<li><strong>バージョンベースのルーティング</strong>:ゲートウェイは、ツールの異なるバージョン間でトラフィックを分割できます。たとえば、90%をv1に、10%をv2のカナリアデプロイメントに送信します。これにより、AIエージェントへの変更を必要とせずに、段階的なロールアウトとA/Bテストが可能になります。</li>\n<li><strong>オーディエンスベースのルーティング</strong>:内部ユーザーはツールのベータバージョンに誘導され、外部ユーザーは安定バージョンにルーティングされます。これにより、より広範なリリース前に内部テストと検証が可能になります。</li>\n<li><strong>リクエストサイズベースのルーティング</strong>:小さいリクエストは標準インスタンスで処理され、より多くのリソースを必要とする大きいリクエストは高メモリインスタンスに誘導されます。これにより、リソース使用率が最適化され、要求の厳しいリクエストが標準操作のパフォーマンスに影響を与えないことが保証されます。</li>\n<li><strong>地理的ルーティング</strong>:異なる地域のユーザーは地域固有のインスタンスに誘導され、レイテンシが削減され、データ居住要件に対処できる可能性があります。</li>\n</ol>\n\n<p>AIエージェントはこれらのルーティング決定を認識する必要はありません。論理的なツール名にリクエストを行うだけで、ゲートウェイが適切なバックエンドへのルーティングの複雑さを処理します。この抽象化により、エージェントの実装が簡素化され、強力な運用機能が提供されます。</p>\n\n<p>同様に、ルーティングは<strong>コンテキスト</strong>を考慮できます—たとえば、ユーザーの場所がわかっている場合は、レイテンシを低くするために最も近い地域サーバーにリクエストを誘導したり、リクエストのサイズに応じて異なるバックエンドを選択したりします(おそらく非常に大きなファイル用の特別な高メモリインスタンス)。これらすべてはプロキシレベルで設定可能です。AIエージェントは論理的なツール名を呼び出すだけで、ゲートウェイが適切なバックエンドを見つけることを処理します。これにより、運用が容易になるだけでなく(AIのインターフェースを壊すことなくバックエンドツールをアップグレードできます)、セキュリティも向上します。テスト用に特定のバージョンを分離したり、実験的なツールが特定の条件下でのみアクセス可能であることを保証したりできます。トラフィックフローを制御することで、プロキシはマクロスケールで<strong>最小権限の原則</strong>を維持するのに役立ちます—AIは、現在のコンテキストに適したルートを介して、到達すべきバックエンドにのみ到達します。</p>\n\n<h2>プロキシを使用したMCPセキュリティの実装:実用的なアプローチ</h2>\n\n<p>主要なセキュリティパターンをカバーしたので、アイデンティティ対応プロキシを使用してMCPセキュリティを実装する実用的なアプローチを見てみましょう。このセクションでは、コンポーネント間の統合ポイントに焦点を当てて、安全なMCP環境をセットアップする手順を概説します。</p>\n\n<pre><code class=\"language-mermaid\">graph TB\n    subgraph ImplementationSteps[\"実装手順\"]\n        Step1[1. アイデンティティプロバイダーのセットアップ]\n        Step2[2. APIゲートウェイの設定]\n        Step3[3. ツールレジストリの実装]\n        Step4[4. セキュリティポリシーの定義]\n        Step5[5. AIエージェントの統合]\n        Step6[6. 監視と監査]\n        \n        Step1 --&gt; Step2\n        Step2 --&gt; Step3\n        Step3 --&gt; Step4\n        Step4 --&gt; Step5\n        Step5 --&gt; Step6\n    end\n    \n    classDef step fill:#beb,stroke:#333,stroke-width:1px\n    class Step1,Step2,Step3,Step4,Step5,Step6 step\n</code></pre>\n\n<p>この図は、プロキシを使用してMCPセキュリティを実装する6つの主要な手順を概説しています。プロセスは論理的な進行に従います:</p>\n\n<ol>\n<li><strong>アイデンティティプロバイダーのセットアップ</strong>:認証と認可の基盤を確立します。</li>\n<li><strong>APIゲートウェイの設定</strong>:中央セキュリティ制御ポイントをセットアップします。</li>\n<li><strong>ツールレジストリの実装</strong>:MCPツールを管理するためのシステムを作成します。</li>\n<li><strong>セキュリティポリシーの定義</strong>:アクセス制御とデータ保護のルールを確立します。</li>\n<li><strong>AIエージェントの統合</strong>:AIエージェントを安全なMCP環境に接続します。</li>\n<li><strong>監視と監査</strong>:システムアクティビティを継続的に追跡およびレビューします。</li>\n</ol>\n\n<p>各ステップは前のステップの上に構築され、包括的なセキュリティ実装を作成します。以下のセクションでは、各ステップを詳しく説明します。</p>\n\n<h3>1. アイデンティティプロバイダーのセットアップ</h3>\n\n<p>最初のステップは、MCPセキュリティに必要なOIDCフローをサポートするようにアイデンティティプロバイダー(IdP)を設定することです。これには通常、次のことが含まれます:</p>\n\n<ol>\n<li>IdP(Azure AD、Okta、Auth0など)でOIDCアプリケーションを作成する</li>\n<li>適切なスコープとクレームを設定する</li>\n<li>AIアプリケーションのリダイレクトURIをセットアップする</li>\n<li>クライアント資格情報(クライアントIDとシークレット)を生成する</li>\n</ol>\n\n<p>IdPは、ユーザーを認証し、MCPリクエストを保護するために使用されるトークンを発行する責任があります。認可決定に必要な情報がトークンに含まれるように、適切なスコープとクレームを設定することが重要です。</p>\n\n<h3>2. APIゲートウェイの設定</h3>\n\n<p>次に、MCPプロキシとして機能するようにAPIゲートウェイを設定する必要があります。これには次のことが含まれます:</p>\n\n<pre><code class=\"language-mermaid\">sequenceDiagram\n    participant Admin as 管理者\n    participant Gateway as APIゲートウェイ\n    participant IdP as アイデンティティプロバイダー\n    \n    Admin-&gt;&gt;Gateway: 1. OIDC統合を設定\n    Gateway-&gt;&gt;IdP: 2. OIDC検出ドキュメントを取得\n    IdP-&gt;&gt;Gateway: 3. エンドポイントとキーを返却\n    \n    Admin-&gt;&gt;Gateway: 4. MCPルーティングルールをセットアップ\n    Admin-&gt;&gt;Gateway: 5. セキュリティポリシーを設定\n    \n    Note over Gateway: ゲートウェイはトークンを検証し、MCPトラフィックをルーティングする準備ができました\n</code></pre>\n\n<p>このシーケンス図は、MCPセキュリティのためにAPIゲートウェイを設定するプロセスを示しています。プロセスは、管理者がゲートウェイでOIDC統合を設定することから始まります。ゲートウェイはアイデンティティプロバイダーからOIDC検出ドキュメントを取得し、トークン検証に必要なエンドポイントとキーを返します。</p>\n\n<p>次に、管理者はMCPルーティングルールをセットアップし、さまざまな基準に基づいてリクエストを異なるMCPツールに誘導する方法を定義します。管理者はまた、誰がどのツールにどのような条件でアクセスできるかを指定するセキュリティポリシーを設定します。</p>\n\n<p>これらの設定が完了すると、ゲートウェイは定義されたルールとポリシーに従ってトークンを検証し、MCPトラフィックをルーティングする準備ができています。このセットアッププロセスにより、ゲートウェイがすべてのMCPインタラクションの中央セキュリティ制御ポイントとして確立されます。</p>\n\n<p>設定手順には次のものが含まれます:</p>\n\n<ol>\n<li>トークン検証パラメータ(発行者、オーディエンスなど)の設定を含むOIDC統合のセットアップ</li>\n<li>MCPリクエストのルーティングルールの定義</li>\n<li>ツールアクセスのセキュリティポリシーの設定</li>\n<li>監査ログのセットアップ</li>\n</ol>\n\n<p>ゲートウェイは、トークンの検証、セキュリティポリシーの実施、MCPリクエストの適切なバックエンドへのルーティングを担当します。ゲートウェイがMCP JSON-RPC形式を処理し、ポリシー決定に必要な情報を抽出するように適切に設定されていることを確認することが重要です。</p>\n\n<h3>3. ツールレジストリの実装</h3>\n\n<p>ツールレジストリは、環境内のMCPツールのライフサイクルを管理するために不可欠です。これには次のことが含まれます:</p>\n\n<ol>\n<li>ツールメタデータを保存するためのデータベースまたはサービスの作成</li>\n<li>新しいツールの登録プロセスの定義</li>\n<li>ツールアクセスの承認ワークフローの実装</li>\n<li>レジストリとAPIゲートウェイの統合</li>\n</ol>\n\n<p>ツールレジストリは、利用可能なツールのリスト、そのエンドポイント、およびアクセス要件を維持する責任があります。また、ルーティングとポリシー実施のためにAPIゲートウェイに必要な情報を提供します。</p>\n\n<pre><code class=\"language-mermaid\">graph TB\n    subgraph \"ツールレジストリ\"\n        DB[(ツールデータベース)]\n        API[レジストリAPI]\n        UI[管理UI]\n        \n        UI --&gt;|ツール管理| API\n        API --&gt;|CRUD操作| DB\n    end\n    \n    subgraph \"統合ポイント\"\n        Gateway[APIゲートウェイ]\n        Agents[AIエージェント]\n        \n        API --&gt;|ツール設定| Gateway\n        API --&gt;|利用可能なツール| Agents\n    end\n    \n    subgraph \"ツールライフサイクル\"\n        Register[登録]\n        Approve[承認]\n        Deploy[デプロイ]\n        Monitor[監視]\n        Retire[廃止]\n        \n        Register --&gt; Approve\n        Approve --&gt; Deploy\n        Deploy --&gt; Monitor\n        Monitor --&gt; Retire\n    end\n    \n    classDef registry fill:#bbf,stroke:#333,stroke-width:1px;\n    classDef integration fill:#fbf,stroke:#333,stroke-width:1px;\n    classDef lifecycle fill:#bfb,stroke:#333,stroke-width:1px;\n    \n    class DB,API,UI registry;\n    class Gateway,Agents integration;\n    class Register,Approve,Deploy,Monitor,Retire lifecycle;\n</code></pre>\n\n<p>この図は、MCP環境におけるツールレジストリのコンポーネントとライフサイクルを示しています。ツールレジストリは3つの主要なコンポーネントで構成されています:</p>\n\n<ol>\n<li><strong>ツールデータベース</strong>:エンドポイント、バージョン、アクセス要件、ステータスを含む、登録されたすべてのMCPツールに関するメタデータを保存します。</li>\n<li><strong>レジストリAPI</strong>:ツールデータベースへのプログラマティックアクセスを提供し、ツール登録のCRUD操作を可能にします。</li>\n<li><strong>管理UI</strong>:管理者が登録、承認、監視を含むユーザーインターフェースを通じてツールを管理できるようにします。</li>\n</ol>\n\n<p>ツールレジストリは2つの主要なシステムと統合されます:\n- <strong>APIゲートウェイ</strong>:レジストリからツール設定を受け取り、ルーティングとポリシー決定に情報を提供します。\n- <strong>AIエージェント</strong>:ユーザー権限とツールステータスに基づいて、レジストリを通じて利用可能なツールを発見します。</p>\n\n<p>図はまた、MCPツールのライフサイクルを示しています:\n1. <strong>登録</strong>:新しいツールがメタデータとともにシステムに登録されます。\n2. <strong>承認</strong>:ツールがレビューを受け、特定のユーザーグループによる使用が承認されます。\n3. <strong>デプロイ</strong>:ツールが本番環境で利用可能になります。\n4. <strong>監視</strong>:ツールの使用とパフォーマンスが監視されます。\n5. <strong>廃止</strong>:不要になったツールはシステムから廃止されます。</p>\n\n<p>このツール管理への包括的なアプローチにより、すべてのMCPツールがライフサイクル全体を通じて適切に検証、デプロイ、監視され、セキュリティリスクと運用上の問題が軽減されます。</p>\n\n<h3>4. セキュリティポリシーの定義</h3>\n\n<p>セキュリティポリシーは、MCPツールへのアクセスを管理するルールです。これには次のことが含まれます:</p>\n\n<ol>\n<li>ツールアクセスのRBACポリシーの定義</li>\n<li>レスポンスのコンテンツフィルタリングルールの設定</li>\n<li>監査ログ要件のセットアップ</li>\n<li>バージョン管理ポリシーの実装</li>\n</ol>\n\n<p>セキュリティポリシーは、ユーザーのアイデンティティとアクセスされているツールに基づいて、APIゲートウェイによって実施されます。ポリシーが包括的で、組織のセキュリティ要件と整合していることを確認することが重要です。</p>\n\n<h3>5. AIエージェントの統合</h3>\n\n<p>最後に、AIエージェントを安全なMCP環境と統合する必要があります。これには次のことが含まれます:</p>\n\n<ol>\n<li>OIDCトークンを取得して使用するようにエージェントを設定する</li>\n<li>MCPクライアント機能の実装</li>\n<li>認証と認可エラーの処理</li>\n<li>トークンリフレッシュとセッション継続の管理</li>\n</ol>\n\n<p>AIエージェントは、必要なトークンを取得し、MCPリクエストに含める責任があります。また、認証と認可エラーを適切に処理し、ユーザーに適切なフィードバックを提供する必要があります。</p>\n\n<pre><code class=\"language-mermaid\">sequenceDiagram\n    participant User as ユーザー\n    participant Agent as AIエージェント\n    participant App as アプリケーション\n    participant IdP as アイデンティティプロバイダー\n    participant Gateway as APIゲートウェイ\n    participant Tool as MCPツール\n    \n    User-&gt;&gt;App: AIアプリケーションにアクセス\n    App-&gt;&gt;IdP: ユーザーを認証\n    IdP-&gt;&gt;App: トークン発行\n    \n    User-&gt;&gt;Agent: AI機能を使用してリクエスト\n    Agent-&gt;&gt;App: MCP用のトークンをリクエスト\n    App-&gt;&gt;Agent: トークンを提供\n    \n    Agent-&gt;&gt;Gateway: トークン付きMCPリクエスト\n    Gateway-&gt;&gt;Gateway: トークンを検証してポリシーを適用\n    Gateway-&gt;&gt;Tool: 認可されたリクエストを転送\n    Tool-&gt;&gt;Gateway: レスポンス\n    Gateway-&gt;&gt;Agent: レスポンス返却\n    Agent-&gt;&gt;User: 結果提示\n    \n    Note over App,Gateway: トークンリフレッシュサイクル\n    App-&gt;&gt;IdP: 必要に応じてトークンをリフレッシュ\n    IdP-&gt;&gt;App: 新しいアクセストークン\n</code></pre>\n\n<p>このシーケンス図は、AIエージェントと安全なMCP環境との統合を示しています。プロセスは、ユーザーがAIアプリケーションにアクセスすると開始され、アプリケーションはアイデンティティプロバイダーでユーザーを認証し、トークンを受け取ります。</p>\n\n<p>ユーザーがAI機能を必要とするリクエストを行うと、AIエージェントはアプリケーションにトークンをリクエストし、アプリケーションはそれを提供します。エージェントは、APIゲートウェイへのMCPリクエストにこのトークンを含めます。</p>\n\n<p>ゲートウェイはトークンを検証し、セキュリティポリシーを適用して、リクエストを許可すべきかどうかを判断します。認可されている場合、リクエストは適切なMCPツールに転送され、処理してレスポンスを返します。このレスポンスはゲートウェイを通じてエージェントに、最終的にユーザーに流れます。</p>\n\n<p>バックグラウンドでは、アプリケーションがトークンリフレッシュサイクルを処理し、必要に応じてアイデンティティプロバイダーに新しいアクセストークンをリクエストします。これにより、ユーザーが頻繁に再認証する必要なく、継続的な操作が保証されます。</p>\n\n<p>この統合アプローチにより、AIエージェントがプロキシアーキテクチャによって確立されたセキュリティフレームワーク内で動作し、すべてのリクエストが適切に認証および認可されることが保証されます。</p>\n\n<h2>結論:美化されたAPI呼び出しを超えて</h2>\n\n<p>アイデンティティ対応プロキシを使用して安全なMCPアーキテクチャを実装することで、「美化されたAPI呼び出し」をはるかに超えて、AIエージェントとビジネスシステム間の堅牢なエンタープライズグレードの統合に移行します。このアプローチは、MCPデプロイメントの主要なセキュリティ課題に対処します:</p>\n\n<ul>\n<li>ユーザーアイデンティティとアクセス制御</li>\n<li>マルチステップコンテキスト交換</li>\n<li>複雑な委任チェーン</li>\n<li>動的ツールプロビジョニング</li>\n<li>リモートMCP変更とバージョン追跡</li>\n</ul>\n\n<p>プロキシベースのアーキテクチャは、セキュリティポリシーを実施し、ツールアクセスを管理し、AIエージェントアクティビティを監視するための一元化された制御ポイントを提供します。また、バックエンドサービスの複雑さを抽象化し、AIエージェントに一貫したインターフェースを提供することで、運用を簡素化します。</p>\n\n<p>MCPが進化し、採用が進むにつれて、この記事で説明されているセキュリティパターンは、エンタープライズデプロイメントにとってますます重要になります。これらのパターンを今実装することで、AIエージェントインフラストラクチャが安全でスケーラブルで、将来に備えていることを保証できます。</p>\n\n<pre><code class=\"language-mermaid\">graph LR\n    A[美化されたAPI呼び出し] --&gt;|進化| B[安全なMCPアーキテクチャ]\n    \n    subgraph \"主要な利点\"\n        C[一元化されたセキュリティ]\n        D[アイデンティティ伝播]\n        E[ポリシー実施]\n        F[監査とコンプライアンス]\n        G[運用の簡素化]\n    end\n    \n    B --&gt; C\n    B --&gt; D\n    B --&gt; E\n    B --&gt; F\n    B --&gt; G\n    \n    classDef benefit fill:#bfb,stroke:#333,stroke-width:1px;\n    class C,D,E,F,G benefit;\n</code></pre>\n\n<p>この最後の図は、「美化されたAPI呼び出し」から安全なMCPアーキテクチャへの進化をまとめ、このアプローチの主要な利点を強調しています:</p>\n\n<ol>\n<li><strong>一元化されたセキュリティ</strong>:すべてのMCPインタラクションにわたってセキュリティポリシーを実施するための単一の制御ポイント。</li>\n<li><strong>アイデンティティ伝播</strong>:システム全体を通じたユーザーアイデンティティと権限の一貫した処理。</li>\n<li><strong>ポリシー実施</strong>:誰がどのツールにどのような条件でアクセスできるかのきめ細かい制御。</li>\n<li><strong>監査とコンプライアンス</strong>:セキュリティとコンプライアンス目的のためのすべてのMCPアクティビティの包括的なログと監視。</li>\n<li><strong>運用の簡素化</strong>:バックエンドの複雑さの抽象化により、時間の経過とともにシステムを管理および進化させることが容易になります。</li>\n</ol>\n\n<p>このアーキテクチャを採用することで、組織はエンタープライズ環境にAIエージェントを自信を持ってデプロイでき、MCPインタラクションが安全で監査可能で、大規模に管理可能であることを知ることができます。これは、AIツールを単なるAPI呼び出しとして見る単純な見方を大きく前進させ、本番AIシステムの複雑なセキュリティ要件を認識しています。</p>",
  "source_hash": "sha256:2e298f37ca328b0eb320a81887dd3640aeb212ad3bf1d820c547bb98ab9e3b19",
  "model": "claude-sonnet-4-5-20250929",
  "generated_at": "2026-01-02T03:20:29.215753+00:00"
}