{
  "title": "Cursorとの1年:ワークフローがエージェントからアーキテクトへと進化した軌跡",
  "excerpt": "Cursorとの私の旅は、ツール自体の成熟を映し出しています。シンプルなエージェントから洗練されたアーキテクチャパートナーへ。この記事では、@メンション、MCP、プランモード、カスタムコマンドを通じて、私のワークフローがどのように進化したかを詳しく紹介します。",
  "content_html": "<p>Cursorを主要なIDEとして使い始めてから1年以上が経ちましたが、それが私の仕事に与えた影響は計り知れません。Dylogで会話型AIプラットフォームを構築する機械学習エンジニアとして、また個人プロジェクトでエージェント型インフラを実験する者として、私はAIネイティブ開発の進化を肌で感じてきました。Cursorとの私の旅は、ツール自体の成熟を映し出しています。シンプルなエージェントから洗練されたアーキテクチャパートナーへと。</p>\n\n<p>この記事は、その旅の振り返りであり、私のワークフローがどのように進化したか、そしてプランモード、カスタムコマンド、コンテキストエンジニアリングの強力な組み合わせに、より速く、よりスマートに、より明確に構築するためにどのように依存するようになったかを詳述します。</p>\n\n<h2>フェーズ1:エージェントがハンドルを握る</h2>\n\n<p>最初の頃、私の使い方はシンプルでした。Cursorを強化版オートコンプリートのように扱っていました。コメントを書いて、<code>Cmd+K</code>を押し、エージェントにコードを生成させる。魔法のようでしたが、同時にブラックボックスでもありました。私は乗客で、エージェントが運転していたのです。</p>\n\n<p>そして<strong>@メンション</strong>が登場しました。これは、エージェントに実際のコンテキストを与える最初の体験でした。コードベースを理解してくれることを期待するのではなく、何を見るべきか明示的に伝えることができるようになりました:</p>\n\n<ul>\n<li><code>@file</code> 特定のファイルを参照</li>\n<li><code>@folder</code> ディレクトリ全体を含める</li>\n<li><code>@codebase</code> プロジェクト全体を検索させる</li>\n<li><code>@web</code> 外部ドキュメントを取得</li>\n<li><code>@docs</code> ライブラリの公式ドキュメントを参照</li>\n</ul>\n\n<p>これは大きな飛躍でした。突然、エージェントは推測するのではなく、私と同じコンテキストで作業するようになりました。「この関数を<code>@file:utils/helpers.ts</code>のパターンに合わせてリファクタリングして」と言えば、実際に理解してくれるのです。</p>\n\n<img src=\"/assets/images/cursor-at-mentions.png\" alt=\"Cursor @ mention context\" class=\"post-img\">\n<span class=\"post-img-caption\">Cursorの@メンションドロップダウン。@file、@folder、@codebase、@web、@docsなどのコンテキストオプションが表示され、明示的なコンテキスト制御が可能</span>\n\n<p>しかし、より良いコンテキストがあっても、生成、デバッグ、再生成のループに陥ることがよくありました。エージェントには、より大きなタスクに対するアーキテクチャのビジョンが欠けていたのです。</p>\n\n<h2>フェーズ2:MCPがすべてを変える</h2>\n\n<p><strong>Model Context Protocol (MCP)</strong>の導入は、事態が本格化した瞬間でした。MCPにより、Cursorを外部ツールやデータソースに接続できるようになり、エージェントはコードジェネレーターから、私のワークフロー全体にアクセスできる真のアシスタントへと変貌しました。</p>\n\n<p>私は以下のようなMCPを統合し始めました:</p>\n\n<ul>\n<li><strong>GitHub</strong> issueやPRを直接コンテキストに取り込む</li>\n<li><strong>Linear</strong> タスク管理の統合</li>\n<li><strong>Slack</strong> チームコミュニケーションのコンテキスト</li>\n<li><strong>カスタムMCP</strong> 内部APIやデータベース用</li>\n</ul>\n\n<p>MCPがあれば、「Linearのissue #234に記載されている機能を実装して」と言うだけで、エージェントがissueを取得し、要件を理解し、構築を始めてくれます。もはやコードだけの話ではなく、開発エコシステム全体で点と点を結ぶことができるようになったのです。</p>\n\n<img src=\"/assets/images/cursor-mcp-integrations.png\" alt=\"MCP integrations in Cursor\" class=\"post-img\">\n<span class=\"post-img-caption\">MCP設定パネル。GitHub、Linear、Slack、カスタムサーバーなどの接続された統合が表示され、開発エコシステム全体でCursorの機能を拡張</span>\n\n<h2>フェーズ3:プランナーの台頭</h2>\n\n<p><strong>プランモード</strong>の導入は、次のゲームチェンジャーでした。AIと協働している感覚を初めて味わえたのです。単に委任するのではなく。Ray Fernandoのような開発者のワークフローに触発され、私は2ステップのプロセスを使い始めました:</p>\n\n<ol>\n<li><strong>Opusでプランニング:</strong> Claude Opusのような強力なモデルを使って、詳細なステップバイステップの実装計画を生成します。高レベルの目標を与えると、ファイル名、関数シグネチャ、ロジックを含む一連の具体的なタスクに分解してくれます。</li>\n\n<li><strong>Sonnet/GPTで実行:</strong> その計画を、SonnetやGPT-5.2のような高速で安価なモデルに渡し、各ステップを実行させます。安価なモデルは優れたアーキテクトである必要はなく、勤勉なビルダーであればよいのです。</li>\n</ol>\n\n<p>このワークフローは大幅な改善でした。「何を」と「どのように」を分離し、コードが書かれる前に編集・承認できるレビュー可能な成果物、つまり計画を得られるようになりました。トークンのコストも大幅に削減できました。</p>\n\n<img src=\"/assets/images/cursor-plan-mode.png\" alt=\"Cursor Plan Mode workflow\" class=\"post-img\">\n<span class=\"post-img-caption\">分割ビュー。左側に<code>.cursor/plans/</code>ファイルの詳細な実装計画、右側に対応する生成されたコードが表示され、アーキテクチャと実行の分離を示している</span>\n\n<h2>フェーズ4:アーキテクトの出現(コマンド + プランニング)</h2>\n\n<p>これが現在の私の立ち位置です。プランモードは依然としてワークフローの中心ですが、プロセスを微調整し、アーキテクチャの原則をIDEに直接組み込むために、<strong>カスタムコマンド</strong>と<strong>ルール</strong>のセットを重ねています。</p>\n\n<h3>現在のセットアップ</h3>\n\n<p><strong>ルール(<code>.cursorrules</code>):</strong> コーディング標準、好みのパターン、アーキテクチャの制約を定義するルールセットがあります。エージェントは各タスクの前にこれらを読み、コードベース全体の一貫性を確保します。</p>\n\n<p><strong>カスタムコマンド:</strong> 最も一般的なワークフローをラップするコマンドを構築しました:</p>\n\n<ul>\n<li><code>/plan</code> - Opusを使用して詳細な実装計画を生成</li>\n<li><code>/refactor</code> - ファイルを取得し、指示に基づいてリファクタリング</li>\n<li><code>/test</code> - 指定された関数のテストスイートを生成</li>\n<li><code>/review</code> - ルールに照らしてコードをレビューし、改善を提案</li>\n</ul>\n\n<p><strong>キューメッセージ:</strong> エージェントが作業中に<code>Ctrl+Enter</code>を使ってフォローアップ指示をキューに入れます。これにより、現在のタスクを中断することなく、先を考え、勢いを維持できます。</p>\n\n<img src=\"/assets/images/cursor-custom-commands.png\" alt=\"Cursor custom commands and rules\" class=\"post-img\">\n<span class=\"post-img-caption\">Cursorコマンドパレット。/plan、/refactor、/test、/reviewなどのカスタムコマンドと、コーディング標準とアーキテクチャの制約を定義する<code>.cursorrules</code>ファイルが表示されている</span>\n\n<h2>進化の概観</h2>\n\n<table>\n<thead>\n<tr>\n<th>フェーズ</th>\n<th>主要機能</th>\n<th>何が変わったか</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>エージェントモード + @メンション</td>\n<td>コンテキストが推測ではなく明示的に</td>\n</tr>\n<tr>\n<td>2</td>\n<td>MCP統合</td>\n<td>外部ツールとデータがアクセス可能に</td>\n</tr>\n<tr>\n<td>3</td>\n<td>プランモード</td>\n<td>アーキテクチャが実行から分離</td>\n</tr>\n<tr>\n<td>4</td>\n<td>コマンド + ルール</td>\n<td>ワークフローが再現可能でパーソナライズ可能に</td>\n</tr>\n</tbody>\n</table>\n\n<h2>なぜこれが重要なのか</h2>\n\n<p>エージェントからアーキテクトへのこの進化は、単なる個人的な生産性ハック以上のものです。これはソフトウェア開発の未来を垣間見るものです。私たちは、コードを書く世界から<strong>システムを記述する</strong>世界へと移行しています。私たちの仕事はアーキテクトになること、青写真を定義すること、そしてエージェントに構築を任せることです。</p>\n\n<p>Cursorは、私が使った他のどのツールよりも、この変化を理解しています。単にコードを生成するだけでなく、複雑さを管理し、コンテキストを維持し、開発者に以前は想像もできなかった規模で構築するレバレッジを与えることが目的なのです。</p>\n\n<p>もしあなたがまだAIをシンプルなコードジェネレーターとして使っているなら、@メンション、MCP、プランモード、カスタムコマンドを探求することをお勧めします。それは、AIを使う開発者から、AIを指揮するアーキテクトへとあなたを変える旅となるでしょう。</p>\n\n<p>覚えておいてください:私たちはもはやコードを書くのではなく、システムを設計するのです。</p>",
  "source_hash": "sha256:662561f10cc6e2a91c66508ff149182da2e11a387f342090ce2e43b96d291d1b",
  "model": "claude-sonnet-4-5-20250929",
  "generated_at": "2026-01-05T01:55:01.186215+00:00"
}