{
  "title": "Un Año con Cursor: Cómo Mi Flujo de Trabajo Evolucionó de Agente a Arquitecto",
  "excerpt": "Mi viaje con Cursor refleja la maduración de la herramienta misma: de un simple agente a un sofisticado socio arquitectónico. Este post detalla cómo mi flujo de trabajo evolucionó a través de menciones @, MCP, Plan Mode y comandos personalizados.",
  "content_html": "<p>Ha pasado más de un año desde que hice de Cursor mi IDE principal, y es difícil exagerar el impacto que ha tenido en mi trabajo. Como ingeniero de aprendizaje automático construyendo plataformas de IA conversacional en Dylog y experimentando con infraestructura agéntica en mis proyectos personales, he vivido la evolución del desarrollo nativo de IA. Mi viaje con Cursor refleja la maduración de la herramienta misma: de un simple agente a un sofisticado socio arquitectónico.</p>\n\n<p>Este post es una reflexión sobre ese viaje, detallando cómo evolucionó mi flujo de trabajo y cómo he llegado a depender de una poderosa combinación de Plan Mode, comandos personalizados e ingeniería de contexto para construir más rápido, más inteligentemente y con mayor claridad.</p>\n\n<h2>Fase 1: El Agente Toma el Control</h2>\n\n<p>Cuando comencé, mi uso era simple. Trataba a Cursor como un autocompletado supercargado. Escribía un comentario, presionaba <code>Cmd+K</code>, y dejaba que el agente generara el código. Era mágico, pero también era una caja negra. Yo era un pasajero, y el agente estaba conduciendo.</p>\n\n<p>Luego llegaron las <strong>menciones @</strong>. Este fue mi primer contacto con darle al agente contexto real. En lugar de esperar que entendiera mi base de código, podía decirle explícitamente qué mirar:</p>\n\n<ul>\n<li><code>@file</code> para referenciar un archivo específico</li>\n<li><code>@folder</code> para incluir un directorio completo</li>\n<li><code>@codebase</code> para permitirle buscar en todo el proyecto</li>\n<li><code>@web</code> para obtener documentación externa</li>\n<li><code>@docs</code> para referenciar documentación oficial de bibliotecas</li>\n</ul>\n\n<p>Este fue un gran salto. De repente, el agente no estaba adivinando; estaba trabajando con el mismo contexto que yo tenía. Podía decir \"refactoriza esta función para que coincida con el patrón en <code>@file:utils/helpers.ts</code>\" y realmente lo entendería.</p>\n\n<p><img src=\"/assets/images/cursor-at-mentions.png\" alt=\"Cursor @ mention context\" class=\"post-img\" />\n<span class=\"post-img-caption\">El menú desplegable de menciones @ en Cursor, mostrando opciones de contexto como @file, @folder, @codebase, @web y @docs que permiten control explícito del contexto</span></p>\n\n<p>Pero incluso con mejor contexto, a menudo me encontraba en un bucle de generar, depurar y regenerar. Al agente le faltaba la visión arquitectónica para tareas más grandes.</p>\n\n<h2>Fase 2: MCP Lo Cambia Todo</h2>\n\n<p>La introducción del <strong>Model Context Protocol (MCP)</strong> fue cuando las cosas se pusieron serias. MCP me permitió conectar Cursor a herramientas externas y fuentes de datos, convirtiendo al agente de un generador de código en un verdadero asistente con acceso a todo mi flujo de trabajo.</p>\n\n<p>Comencé a integrar MCPs para:</p>\n\n<ul>\n<li><strong>GitHub</strong> para obtener issues y PRs directamente en el contexto</li>\n<li><strong>Linear</strong> para integración de gestión de tareas</li>\n<li><strong>Slack</strong> para contexto de comunicación del equipo</li>\n<li><strong>MCPs personalizados</strong> para APIs internas y bases de datos</li>\n</ul>\n\n<p>Con MCP, podía decir \"implementa la funcionalidad descrita en el issue #234 de Linear\" y el agente obtendría el issue, entendería los requisitos y comenzaría a construir. Ya no se trataba solo de código; se trataba de conectar los puntos en todo mi ecosistema de desarrollo.</p>\n\n<p><img src=\"/assets/images/cursor-mcp-integrations.png\" alt=\"MCP integrations in Cursor\" class=\"post-img\" />\n<span class=\"post-img-caption\">Panel de configuración de MCP mostrando integraciones conectadas como GitHub, Linear, Slack y servidores personalizados que extienden las capacidades de Cursor a través del ecosistema de desarrollo</span></p>\n\n<h2>Fase 3: El Surgimiento del Planificador</h2>\n\n<p>La introducción del <strong>Plan Mode</strong> fue el siguiente cambio revolucionario. Fue la primera vez que sentí que estaba colaborando con la IA, no solo delegando en ella. Inspirado por flujos de trabajo de desarrolladores como Ray Fernando, comencé a usar un proceso de dos pasos:</p>\n\n<ol>\n<li><p><strong>Planificar con Opus:</strong> Usaba un modelo poderoso como Claude Opus para generar un plan de implementación detallado, paso a paso. Le daba el objetivo de alto nivel, y lo descomponía en una serie de tareas concretas, completas con nombres de archivos, firmas de funciones y lógica.</p></li>\n<li><p><strong>Ejecutar con Sonnet/GPT:</strong> Luego entregaba ese plan a un modelo más rápido y económico como Sonnet o GPT-5.2 para ejecutar cada paso. El modelo más económico no necesitaba ser un arquitecto brillante; solo necesitaba ser un constructor diligente.</p></li>\n</ol>\n\n<p>Este flujo de trabajo fue una mejora masiva. Separó el \"qué\" del \"cómo\", y me dio un artefacto revisable—el plan—que podía editar y aprobar antes de que se escribiera cualquier código. También ahorró una tonelada de dinero en tokens.</p>\n\n<p><img src=\"/assets/images/cursor-plan-mode.png\" alt=\"Cursor Plan Mode workflow\" class=\"post-img\" />\n<span class=\"post-img-caption\">Una vista dividida mostrando un plan de implementación detallado en un archivo <code>.cursor/plans/</code> a la izquierda, y el código generado correspondiente a la derecha, demostrando la separación de la arquitectura de la ejecución</span></p>\n\n<h2>Fase 4: El Arquitecto Emerge (Comandos + Planificación)</h2>\n\n<p>Aquí es donde vivo hoy. Aunque Plan Mode sigue siendo central en mi flujo de trabajo, he añadido un conjunto de <strong>comandos personalizados</strong> y <strong>reglas</strong> para afinar el proceso e incorporar mis principios arquitectónicos directamente en el IDE.</p>\n\n<h3>Mi Configuración Actual</h3>\n\n<p><strong>Reglas (<code>.cursorrules</code>):</strong> Tengo un conjunto de reglas que definen mis estándares de codificación, patrones preferidos y restricciones arquitectónicas. El agente lee estas antes de cada tarea, asegurando consistencia en toda la base de código.</p>\n\n<p><strong>Comandos Personalizados:</strong> He construido comandos que envuelven mis flujos de trabajo más comunes:</p>\n\n<ul>\n<li><code>/plan</code> - Genera un plan de implementación detallado usando Opus</li>\n<li><code>/refactor</code> - Toma un archivo y lo refactoriza según las instrucciones</li>\n<li><code>/test</code> - Genera un conjunto de pruebas para una función dada</li>\n<li><code>/review</code> - Revisa el código contra mis reglas y sugiere mejoras</li>\n</ul>\n\n<p><strong>Mensajes en Cola:</strong> Uso <code>Ctrl+Enter</code> para poner en cola instrucciones de seguimiento mientras el agente está trabajando. Esto me permite pensar con anticipación y mantener el impulso sin interrumpir la tarea actual.</p>\n\n<p><img src=\"/assets/images/cursor-custom-commands.png\" alt=\"Cursor custom commands and rules\" class=\"post-img\" />\n<span class=\"post-img-caption\">La paleta de comandos de Cursor mostrando comandos personalizados como /plan, /refactor, /test y /review, junto con un archivo <code>.cursorrules</code> que define estándares de codificación y restricciones arquitectónicas</span></p>\n\n<h2>La Evolución de un Vistazo</h2>\n\n<table>\n<thead>\n<tr>\n<th>Fase</th>\n<th>Característica Clave</th>\n<th>Qué Cambió</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>Agent Mode + Menciones @</td>\n<td>El contexto se volvió explícito, no adivinado</td>\n</tr>\n<tr>\n<td>2</td>\n<td>Integración MCP</td>\n<td>Herramientas y datos externos se volvieron accesibles</td>\n</tr>\n<tr>\n<td>3</td>\n<td>Plan Mode</td>\n<td>La arquitectura se separó de la ejecución</td>\n</tr>\n<tr>\n<td>4</td>\n<td>Comandos + Reglas</td>\n<td>Los flujos de trabajo se volvieron repetibles y personalizados</td>\n</tr>\n</tbody>\n</table>\n\n<h2>Por Qué Esto Importa</h2>\n\n<p>Esta evolución de agente a arquitecto es más que un simple truco de productividad personal. Es un vistazo al futuro del desarrollo de software. Estamos pasando de un mundo donde escribimos código a un mundo donde <strong>describimos sistemas</strong>. Nuestro trabajo es ser el arquitecto, definir el plano, y dejar que los agentes hagan la construcción.</p>\n\n<p>Cursor, más que cualquier otra herramienta que he usado, entiende este cambio. No se trata solo de generar código; se trata de gestionar la complejidad, mantener el contexto y dar a los desarrolladores el apalancamiento para construir a una escala que antes era inimaginable.</p>\n\n<p>Si todavía estás usando IA como un simple generador de código, te animo a explorar las menciones @, MCP, Plan Mode y comandos personalizados. Es un viaje que te transformará de un desarrollador que usa IA a un arquitecto que la dirige.</p>",
  "source_hash": "sha256:662561f10cc6e2a91c66508ff149182da2e11a387f342090ce2e43b96d291d1b",
  "model": "claude-sonnet-4-5-20250929",
  "generated_at": "2026-01-05T01:54:40.691375+00:00"
}