{
  "title": "Ein Jahr mit Cursor: Wie sich mein Workflow vom Agenten zum Architekten entwickelte",
  "excerpt": "Meine Reise mit Cursor spiegelt die Reifung des Tools selbst wider: von einem einfachen Agenten zu einem ausgeklügelten architektonischen Partner. Dieser Beitrag beschreibt, wie sich mein Workflow durch @ Erwähnungen, MCP, Plan-Modus und benutzerdefinierte Befehle entwickelt hat.",
  "content_html": "<p>Es ist über ein Jahr her, seit ich Cursor zu meiner primären IDE gemacht habe, und es ist schwer, die Auswirkungen auf meine Arbeit zu überschätzen. Als Machine Learning Engineer, der Conversational AI-Plattformen bei Dylog entwickelt und mit agentischer Infrastruktur in meinen persönlichen Projekten experimentiert, habe ich die Evolution der KI-nativen Entwicklung miterlebt. Meine Reise mit Cursor spiegelt die Reifung des Tools selbst wider: von einem einfachen Agenten zu einem ausgeklügelten architektonischen Partner.</p>\n\n<p>Dieser Beitrag ist eine Reflexion über diese Reise und beschreibt, wie sich mein Workflow entwickelt hat und wie ich mich auf eine leistungsstarke Kombination aus Plan-Modus, benutzerdefinierten Befehlen und Context Engineering verlasse, um schneller, intelligenter und mit mehr Klarheit zu entwickeln.</p>\n\n<h2>Phase 1: Der Agent übernimmt das Steuer</h2>\n\n<p>Als ich anfing, war meine Nutzung einfach. Ich behandelte Cursor wie eine aufgepeppte Autovervollständigung. Ich schrieb einen Kommentar, drückte <code>Cmd+K</code> und ließ den Agenten den Code generieren. Es war magisch, aber es war auch eine Black Box. Ich war ein Passagier, und der Agent fuhr.</p>\n\n<p>Dann kamen die <strong>@ Erwähnungen</strong>. Das war mein erster Vorgeschmack darauf, dem Agenten echten Kontext zu geben. Anstatt zu hoffen, dass er meine Codebasis verstand, konnte ich ihm explizit sagen, worauf er schauen sollte:</p>\n\n<ul>\n<li><code>@file</code> um auf eine bestimmte Datei zu verweisen</li>\n<li><code>@folder</code> um ein ganzes Verzeichnis einzubeziehen</li>\n<li><code>@codebase</code> um im gesamten Projekt suchen zu lassen</li>\n<li><code>@web</code> um externe Dokumentation einzubeziehen</li>\n<li><code>@docs</code> um auf offizielle Dokumentation für Bibliotheken zu verweisen</li>\n</ul>\n\n<p>Das war ein riesiger Sprung. Plötzlich riet der Agent nicht mehr; er arbeitete mit demselben Kontext, den ich hatte. Ich konnte sagen \"refaktoriere diese Funktion, um dem Muster in <code>@file:utils/helpers.ts</code> zu entsprechen\" und er würde es tatsächlich verstehen.</p>\n\n<p><img src=\"/assets/images/cursor-at-mentions.png\" alt=\"Cursor @ mention context\" class=\"post-img\" />\n<span class=\"post-img-caption\">Das @ Erwähnungs-Dropdown in Cursor zeigt Kontextoptionen wie @file, @folder, @codebase, @web und @docs, die eine explizite Kontextkontrolle ermöglichen</span></p>\n\n<p>Aber selbst mit besserem Kontext fand ich mich oft in einer Schleife aus Generieren, Debuggen und Regenerieren wieder. Dem Agenten fehlte die architektonische Vision für größere Aufgaben.</p>\n\n<h2>Phase 2: MCP verändert alles</h2>\n\n<p>Die Einführung des <strong>Model Context Protocol (MCP)</strong> war der Moment, als es ernst wurde. MCP ermöglichte es mir, Cursor mit externen Tools und Datenquellen zu verbinden und verwandelte den Agenten von einem Code-Generator in einen echten Assistenten mit Zugriff auf meinen gesamten Workflow.</p>\n\n<p>Ich begann, MCPs zu integrieren für:</p>\n\n<ul>\n<li><strong>GitHub</strong> zum direkten Abrufen von Issues und PRs in den Kontext</li>\n<li><strong>Linear</strong> für Task-Management-Integration</li>\n<li><strong>Slack</strong> für Team-Kommunikationskontext</li>\n<li><strong>Custom MCPs</strong> für interne APIs und Datenbanken</li>\n</ul>\n\n<p>Mit MCP konnte ich sagen \"implementiere das Feature, das in Linear Issue #234 beschrieben ist\" und der Agent würde das Issue abrufen, die Anforderungen verstehen und mit der Entwicklung beginnen. Es ging nicht mehr nur um Code; es ging darum, die Punkte in meinem gesamten Entwicklungs-Ökosystem zu verbinden.</p>\n\n<p><img src=\"/assets/images/cursor-mcp-integrations.png\" alt=\"MCP integrations in Cursor\" class=\"post-img\" />\n<span class=\"post-img-caption\">MCP-Konfigurationspanel zeigt verbundene Integrationen wie GitHub, Linear, Slack und benutzerdefinierte Server, die Cursors Fähigkeiten über das gesamte Entwicklungs-Ökosystem erweitern</span></p>\n\n<h2>Phase 3: Der Aufstieg des Planers</h2>\n\n<p>Die Einführung des <strong>Plan-Modus</strong> war der nächste Game-Changer. Es war das erste Mal, dass ich das Gefühl hatte, mit der KI zusammenzuarbeiten, nicht nur an sie zu delegieren. Inspiriert von Workflows von Entwicklern wie Ray Fernando begann ich, einen zweistufigen Prozess zu verwenden:</p>\n\n<ol>\n<li><p><strong>Planen mit Opus:</strong> Ich würde ein leistungsstarkes Modell wie Claude Opus verwenden, um einen detaillierten, schrittweisen Implementierungsplan zu generieren. Ich gab ihm das übergeordnete Ziel, und es würde es in eine Reihe konkreter Aufgaben aufschlüsseln, komplett mit Dateinamen, Funktionssignaturen und Logik.</p></li>\n<li><p><strong>Ausführen mit Sonnet/GPT:</strong> Ich würde dann diesen Plan an ein schnelleres, günstigeres Modell wie Sonnet oder GPT-5.2 übergeben, um jeden Schritt auszuführen. Das günstigere Modell musste kein brillanter Architekt sein; es musste nur ein gewissenhafter Baumeister sein.</p></li>\n</ol>\n\n<p>Dieser Workflow war eine massive Verbesserung. Er trennte das \"Was\" vom \"Wie\", und er gab mir ein überprüfbares Artefakt – den Plan – den ich bearbeiten und genehmigen konnte, bevor Code geschrieben wurde. Es sparte auch eine Menge Geld bei den Tokens.</p>\n\n<p><img src=\"/assets/images/cursor-plan-mode.png\" alt=\"Cursor Plan Mode workflow\" class=\"post-img\" />\n<span class=\"post-img-caption\">Eine geteilte Ansicht zeigt einen detaillierten Implementierungsplan in einer <code>.cursor/plans/</code>-Datei auf der linken Seite und den entsprechenden generierten Code auf der rechten Seite, was die Trennung von Architektur und Ausführung demonstriert</span></p>\n\n<h2>Phase 4: Der Architekt entsteht (Befehle + Planung)</h2>\n\n<p>Hier lebe ich heute. Während der Plan-Modus immer noch zentral für meinen Workflow ist, habe ich eine Reihe von <strong>benutzerdefinierten Befehlen</strong> und <strong>Regeln</strong> hinzugefügt, um den Prozess zu verfeinern und meine architektonischen Prinzipien direkt in die IDE einzubacken.</p>\n\n<h3>Mein aktuelles Setup</h3>\n\n<p><strong>Regeln (<code>.cursorrules</code>):</strong> Ich habe eine Reihe von Regeln, die meine Coding-Standards, bevorzugte Muster und architektonische Einschränkungen definieren. Der Agent liest diese vor jeder Aufgabe und stellt so Konsistenz in der gesamten Codebasis sicher.</p>\n\n<p><strong>Benutzerdefinierte Befehle:</strong> Ich habe Befehle erstellt, die meine häufigsten Workflows umschließen:</p>\n\n<ul>\n<li><code>/plan</code> - Generiert einen detaillierten Implementierungsplan mit Opus</li>\n<li><code>/refactor</code> - Nimmt eine Datei und refaktoriert sie basierend auf Anweisungen</li>\n<li><code>/test</code> - Generiert eine Test-Suite für eine gegebene Funktion</li>\n<li><code>/review</code> - Überprüft Code gegen meine Regeln und schlägt Verbesserungen vor</li>\n</ul>\n\n<p><strong>Warteschlangen-Nachrichten:</strong> Ich verwende <code>Ctrl+Enter</code>, um Folgeanweisungen in die Warteschlange zu stellen, während der Agent arbeitet. Das ermöglicht es mir, vorauszudenken und die Dynamik aufrechtzuerhalten, ohne die aktuelle Aufgabe zu unterbrechen.</p>\n\n<p><img src=\"/assets/images/cursor-custom-commands.png\" alt=\"Cursor custom commands and rules\" class=\"post-img\" />\n<span class=\"post-img-caption\">Die Cursor-Befehlspalette zeigt benutzerdefinierte Befehle wie /plan, /refactor, /test und /review, zusammen mit einer <code>.cursorrules</code>-Datei, die Coding-Standards und architektonische Einschränkungen definiert</span></p>\n\n<h2>Die Evolution auf einen Blick</h2>\n\n<table>\n<thead>\n<tr>\n<th>Phase</th>\n<th>Hauptmerkmal</th>\n<th>Was sich änderte</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>Agent-Modus + @ Erwähnungen</td>\n<td>Kontext wurde explizit, nicht erraten</td>\n</tr>\n<tr>\n<td>2</td>\n<td>MCP-Integration</td>\n<td>Externe Tools und Daten wurden zugänglich</td>\n</tr>\n<tr>\n<td>3</td>\n<td>Plan-Modus</td>\n<td>Architektur wurde von der Ausführung getrennt</td>\n</tr>\n<tr>\n<td>4</td>\n<td>Befehle + Regeln</td>\n<td>Workflows wurden wiederholbar und personalisiert</td>\n</tr>\n</tbody>\n</table>\n\n<h2>Warum das wichtig ist</h2>\n\n<p>Diese Evolution vom Agenten zum Architekten ist mehr als nur ein persönlicher Produktivitäts-Hack. Es ist ein Einblick in die Zukunft der Softwareentwicklung. Wir bewegen uns von einer Welt, in der wir Code schreiben, zu einer Welt, in der wir <strong>Systeme beschreiben</strong>. Unsere Aufgabe ist es, der Architekt zu sein, den Bauplan zu definieren und die Agenten das Bauen übernehmen zu lassen.</p>\n\n<p>Cursor versteht diese Verschiebung mehr als jedes andere Tool, das ich verwendet habe. Es geht nicht nur darum, Code zu generieren; es geht darum, Komplexität zu verwalten, Kontext zu bewahren und Entwicklern die Hebelwirkung zu geben, in einem Maßstab zu bauen, der zuvor unvorstellbar war.</p>\n\n<p>Wenn Sie KI immer noch als einfachen Code-Generator verwenden, ermutige ich Sie, @ Erwähnungen, MCP, Plan-Modus und benutzerdefinierte Befehle zu erkunden. Es ist eine Reise, die Sie von einem Entwickler, der KI verwendet, zu einem Architekten verwandeln wird, der sie dirigiert.</p>",
  "source_hash": "sha256:662561f10cc6e2a91c66508ff149182da2e11a387f342090ce2e43b96d291d1b",
  "model": "claude-sonnet-4-5-20250929",
  "generated_at": "2026-01-05T01:54:48.030855+00:00"
}