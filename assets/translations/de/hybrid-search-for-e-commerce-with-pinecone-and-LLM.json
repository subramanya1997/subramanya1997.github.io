{
  "title": "Hybride Suche für E-Commerce mit Pinecone und LLMs",
  "excerpt": "Erfahren Sie, wie Sie ein leistungsstarkes hybrides Suchsystem für E-Commerce-Anwendungen aufbauen, indem Sie traditionelle Information-Retrieval-Methoden mit Machine-Learning-Modellen wie Language Models (LLMs) und Pinecone, einer verwalteten Vektordatenbank, kombinieren. Entdecken Sie die Vorteile der hybriden Suche für E-Commerce, einschließlich verbesserter Suchrelevanz, Personalisierung, Handhabung von Long-Tail-Anfragen und vereinfachtem Infrastrukturmanagement.",
  "content_html": "<p>Die Suche nach relevanten Produkten ist eine kritische Komponente einer E-Commerce-Website. Schnelle und präzise Suchergebnisse können den Unterschied zwischen hoher Benutzerzufriedenheit und Frustration ausmachen. Mit den jüngsten Fortschritten im Bereich des natürlichen Sprachverständnisses und der Vektorsuchtechnologien sind verbesserte Suchsysteme zugänglicher und effizienter geworden, was zu besseren Benutzererfahrungen und höheren Konversionsraten führt.</p>\n\n<p>In diesem Blogbeitrag werden wir untersuchen, wie man ein hybrides Suchsystem für E-Commerce mit Pinecone, einer hochperformanten Vektor-Suchmaschine, und fein abgestimmten domänenspezifischen Sprachmodellen implementiert. Am Ende dieses Beitrags werden Sie nicht nur ein solides Verständnis der hybriden Suche haben, sondern auch eine praktische Schritt-für-Schritt-Anleitung zur Implementierung.</p>\n\n<h2>Was ist Hybride Suche?</h2>\n\n<img src=\"/assets/images/pinecone_hybrid_index.jpg\" class=\"post-img\" alt=\"Pinecone Hybrid Index\">\n<span class=\"post-img-caption\">High-level-Ansicht eines einfachen Pinecone Hybrid Index</span>\n\n<p>Bevor wir uns in die Implementierung vertiefen, lassen Sie uns zunächst verstehen, was hybride Suche bedeutet. Hybride Suche ist ein Ansatz, der die Stärken sowohl der traditionellen Suche (Sparse-Vektor-Suche) als auch der Vektorsuche (Dense-Vektor-Suche) kombiniert, um eine bessere Suchleistung über eine Vielzahl von Domänen hinweg zu erzielen.</p>\n\n<p>Die Dense-Vektor-Suche extrahiert hochwertige Vektor-Embeddings aus Textdaten und führt eine Ähnlichkeitssuche durch, um relevante Dokumente zu finden. Sie hat jedoch oft Schwierigkeiten mit domänenfremden Daten, wenn sie nicht auf domänenspezifische Datensätze fein abgestimmt wurde.</p>\n\n<p>Auf der anderen Seite verwendet die traditionelle Suche Sparse-Vektor-Darstellungen wie Term Frequency-Inverse Document Frequency (TF-IDF) oder BM25 und benötigt keine domänenspezifische Feinabstimmung. Während sie neue Domänen handhaben kann, ist ihre Leistung durch ihre Unfähigkeit begrenzt, semantische Beziehungen zwischen Wörtern zu verstehen, und es fehlt ihr die Intelligenz der Dense-Retrieval-Methoden.</p>\n\n<p>Die hybride Suche versucht, die Schwächen beider Ansätze zu mindern, indem sie diese in einem einzigen System kombiniert und dabei das Leistungspotenzial der Dense-Vektor-Suche und die Zero-Shot-Anpassungsfähigkeit der traditionellen Suche nutzt.</p>\n\n<p>Nachdem wir nun ein grundlegendes Verständnis der hybriden Suche haben, lassen Sie uns in ihre Implementierung eintauchen.</p>\n\n<h2>Aufbau eines hybriden Suchsystems</h2>\n\n<p>Wir werden die folgenden Schritte für die Implementierung eines hybriden Suchsystems behandeln:</p>\n\n<ol>\n<li>Nutzung domänenspezifischer Sprachmodelle</li>\n<li>Erstellung von Sparse- und Dense-Vektoren</li>\n<li>Einrichtung von Pinecone</li>\n<li>Implementierung der hybriden Such-Pipeline</li>\n<li>Durchführung von Abfragen und Parameterabstimmung</li>\n</ol>\n\n<h3>1. Nutzung domänenspezifischer Sprachmodelle</h3>\n\n<p>In den letzten Jahren sind großangelegte vortrainierte Sprachmodelle wie OpenAI's GPT und Cohere für eine Vielzahl von Aufgaben, einschließlich des Verstehens und der Generierung natürlicher Sprache, immer beliebter geworden. Diese Modelle können auf domänenspezifischen Daten fein abgestimmt werden, um ihre Leistung zu verbessern und sich an spezifische Aufgaben anzupassen, wie z.B. die E-Commerce-Produktsuche.</p>\n\n<p>In unserem Beispiel werden wir ein fein abgestimmtes domänenspezifisches Sprachmodell verwenden, um Dense-Vektor-Embeddings für Produkte und Anfragen zu generieren. Sie können jedoch auch andere Modelle wählen oder sogar Ihre eigenen benutzerdefinierten Embeddings basierend auf Ihrer spezifischen Domäne erstellen.</p>\n\n<pre><code class=\"language-python\">import torch\nfrom transformers import AutoTokenizer, AutoModel\n\n# Laden eines vortrainierten domänenspezifischen Sprachmodells\nmodel_name = \"your-domain-specific-model\"\ntokenizer = AutoTokenizer.from_pretrained(model_name)\nmodel = AutoModel.from_pretrained(model_name)\n\n# Generierung von Dense-Vektor-Embeddings für eine Produktbeschreibung\ntext = \"Nike Air Max sports shoes for men\"\ninputs = tokenizer(text, return_tensors=\"pt\")\nwith torch.no_grad():\n    outputs = model(**inputs)\n    dense_embedding = outputs.last_hidden_state.mean(dim=1).numpy()\n</code></pre>\n\n<h3>2. Erstellung von Sparse- und Dense-Vektoren</h3>\n\n<p>Die hybride Suche erfordert sowohl Sparse- als auch Dense-Vektor-Darstellungen für unsere E-Commerce-Daten. Wir werden nun beschreiben, wie diese Vektoren generiert werden.</p>\n\n<h4>Sparse-Vektoren</h4>\n\n<p>Sparse-Vektor-Darstellungen wie TF-IDF oder BM25 können mit standardmäßigen Textverarbeitungstechniken wie Tokenisierung, Stopwort-Entfernung und Stemming erstellt werden. Ein Beispiel für die Generierung von Sparse-Vektoren kann mithilfe einer Vokabularmatrix erreicht werden.</p>\n\n<pre><code class=\"language-python\"># Diese Funktion generiert Sparse-Vektor-Darstellungen einer Liste von Produktbeschreibungen\ndef generate_sparse_vectors(text):\n    '''Generiert Sparse-Vektor-Darstellungen für eine Liste von Produktbeschreibungen\n\n    Args:\n        text (list): Eine Liste von Produktbeschreibungen\n\n    Returns:\n        sparse_vector (dict): Ein Wörterbuch mit Indizes und Werten\n    '''\n    sparse_vector = bm25.encode_queries(text)\n    return sparse_vector\n\nfrom pinecone_text.sparse import BM25Encoder\n\n# Erstellen des BM25-Encoders und Anpassen an die Daten\nbm25 = BM25Encoder()\nbm25.fit(new_df.full_data)\n\n# Erstellen der Sparse-Vektoren\nsparse_vectors = []\nfor product_description in product_descriptions:\n    sparse_vectors.append(generate_sparse_vectors(text=product_description))\n</code></pre>\n\n<h4>Dense-Vektoren</h4>\n\n<p>Dense-Vektor-Darstellungen können mit vortrainierten oder benutzerdefinierten domänenspezifischen Sprachmodellen generiert werden. In unserem vorherigen Beispiel haben wir ein domänenspezifisches Sprachmodell verwendet, um Dense-Vektor-Embeddings für eine Produktbeschreibung zu generieren.</p>\n\n<pre><code class=\"language-python\">def generate_dense_vector(text):\n    '''Generiert Dense-Vektor-Embeddings für eine Liste von Produktbeschreibungen\n\n    Args:\n        text (list): Eine Liste von Produktbeschreibungen\n\n    Returns:\n        dense_embedding (np.array): Ein Numpy-Array von Dense-Vektor-Embeddings\n    '''\n    # Tokenisierung des Texts und Konvertierung in PyTorch-Tensoren\n    inputs = tokenizer(text, return_tensors=\"pt\")\n    # Generierung der Embeddings mit dem vortrainierten Modell\n    with torch.no_grad():\n        outputs = model(**inputs)\n        dense_vector = outputs.last_hidden_state.mean(dim=1).numpy()\n    return dense_vector\n\n# Generierung von Dense-Vektor-Embeddings für eine Liste von Produktbeschreibungen\ndense_vectors = []\nfor product_description in product_descriptions:\n    dense_vectors.append(generate_dense_vector(text=product_description))\n</code></pre>\n\n<h3>3. Einrichtung von Pinecone</h3>\n\n<p>Pinecone ist eine hochperformante Vektor-Suchmaschine, die hybride Suche unterstützt. Sie ermöglicht die Erstellung eines einzigen Index für sowohl Sparse- als auch Dense-Vektoren und verarbeitet nahtlos Suchanfragen über verschiedene Datenmodalitäten hinweg.</p>\n\n<p>Um Pinecone zu verwenden, müssen Sie sich für ein Konto anmelden, den Pinecone-Client installieren und Ihren API-Schlüssel sowie Ihre Umgebung einrichten.</p>\n\n<pre><code class=\"language-python\"># Erstellen eines Pinecone-Hybrid-Such-Index\nimport pinecone\n\npinecone.init(\n    api_key=\"YOUR_API_KEY\",  # app.pinecone.io\n    environment=\"YOUR_ENV\"  # find next to api key in console\n)\n\n# Erstellen eines Pinecone-Hybrid-Such-Index\nindex_name = \"ecommerce-hybrid-search\"\npinecone.create_index(\n    index_name = index_name,\n    dimension = MODEL_DIMENSION,  # dimensionality of dense model\n    metric = \"dotproduct\"\n)\n# Verbindung zum Index herstellen\nindex = pinecone.Index(index_name=index_name)\n# Index-Statistiken anzeigen\nindex.describe_index_stats()\n</code></pre>\n\n<h3>4. Implementierung der hybriden Such-Pipeline</h3>\n\n<p>Mit unseren generierten Sparse- und Dense-Vektoren und der Einrichtung von Pinecone können wir nun eine hybride Such-Pipeline aufbauen. Diese Pipeline umfasst die folgenden Schritte:</p>\n\n<ol>\n<li>Hinzufügen von Produktdaten zum Pinecone-Index</li>\n<li>Abrufen von Ergebnissen unter Verwendung sowohl von Sparse- als auch Dense-Vektoren</li>\n</ol>\n\n<pre><code class=\"language-python\">def add_product_data_to_index(product_ids, sparse_vectors, dense_vectors, metadata=None):\n    \"\"\"Fügt Produktdaten zum Pinecone-Index hinzu.\n\n    Args:\n        product_ids (`list` of `str`): Produkt-IDs.\n        sparse_vectors (`list` of `list` of `float`): Sparse-Vektoren.\n        dense_vectors (`list` of `list` of `float`): Dense-Vektoren.\n        metadata (`list` of `list` of `str`): Optionale Metadaten.\n\n    Returns:\n        None\n    \"\"\"\n    batch_size = 32\n\n    # Durchlaufen der Produkt-IDs in Batches.\n    for i in range(0, len(product_ids), batch_size):\n        i_end = min(i + batch_size, len(product_ids))\n        ids = product_ids[i:i_end]\n        sparse_batch = sparse_vectors[i:i_end]\n        dense_batch = dense_vectors[i:i_end]\n        meta_batch = metadata[i:i_end] if metadata else []\n\n        vectors = []\n        for _id, sparse, dense, meta in zip(ids, sparse_batch, dense_batch, meta_batch):\n            vectors.append({\n                'id': _id,\n                'sparse_values': sparse,\n                'values': dense,\n                'metadata': meta\n            })\n\n        # Einfügen der Vektoren in den Pinecone-Index.\n        index.upsert(vectors=vectors)\n\nadd_product_data_to_index(product_ids, sparse_vectors, dense_vectors)\n</code></pre>\n\n<p>Nachdem unsere Daten indexiert sind, können wir hybride Suchanfragen durchführen.</p>\n\n<h3>5. Durchführung von Abfragen und Parameterabstimmung</h3>\n\n<img src=\"/assets/images/pinecone_hybrid_query.jpg\" class=\"post-img\" alt=\"Pinecone Hybrid Query\">\n<span class=\"post-img-caption\">High-level-Ansicht einer einfachen Pinecone Hybrid Query</span>\n\n<p>Um hybride Suchanfragen durchzuführen, erstellen wir eine Funktion, die eine Anfrage, die Anzahl der Top-Ergebnisse und einen Alpha-Parameter zur Steuerung der Gewichtung zwischen Dense- und Sparse-Vektor-Such-Scores entgegennimmt.</p>\n\n<pre><code class=\"language-python\">def hybrid_scale(dense, sparse, alpha: float):\n    \"\"\"Hybride Vektorskalierung unter Verwendung einer konvexen Kombination\n\n    alpha * dense + (1 - alpha) * sparse\n\n    Args:\n        dense: Array von Floats\n        sparse: ein Dict mit `indices` und `values`\n        alpha: Float zwischen 0 und 1, wobei 0 == nur Sparse\n               und 1 == nur Dense\n    \"\"\"\n    if alpha &lt; 0 or alpha &gt; 1:\n        raise ValueError(\"Alpha muss zwischen 0 und 1 liegen\")\n    # Skalierung von Sparse- und Dense-Vektoren zur Erstellung hybrider Such-Vektoren\n    hsparse = {\n        'indices': sparse['indices'],\n        'values':  [v * (1 - alpha) for v in sparse['values']]\n    }\n    hdense = [v * alpha for v in dense]\n    return hdense, hsparse\n\ndef search_products(query, top_k=10, alpha=0.5):\n    # Generierung des Sparse-Anfragevektors\n    sparse_query_vector = generate_sparse_vector(query)\n\n    # Generierung des Dense-Anfragevektors\n    dense_query_vector = generate_dense_vector(query)\n\n    # Berechnung des hybriden Anfragevektors\n    dense_query_vector, sparse_query_vector = hybrid_scale(dense_query_vector, sparse_query_vector, alpha)\n\n    # Produktsuche mit Pinecone\n    results = index.query(\n        vector=dense_query_vector,\n        sparse_vector=sparse_query_vector,\n        top_k=top_k\n    )\n\n    return results\n</code></pre>\n\n<p>Wir können diese Funktion dann verwenden, um nach relevanten Produkten in unserem E-Commerce-Datensatz zu suchen.</p>\n\n<pre><code class=\"language-python\">query = \"running shoes for women\"\nresults = search_products(query, top_k=5)\n\nfor result in results:\n    print(result['id'], result['metadata']['product_name'], result['score'])\n</code></pre>\n\n<p>Das Experimentieren mit verschiedenen Werten für den Alpha-Parameter hilft Ihnen, die optimale Balance zwischen Sparse- und Dense-Vektor-Suche für Ihre spezifische Domäne zu finden.</p>\n\n<h2>Fazit</h2>\n\n<p>In diesem Blogbeitrag haben wir demonstriert, wie man ein hybrides Suchsystem für E-Commerce mit Pinecone und domänenspezifischen Sprachmodellen aufbaut. Die hybride Suche ermöglicht es uns, die Stärken sowohl der traditionellen Suche als auch der Vektorsuche zu kombinieren und dadurch die Suchleistung und Anpassungsfähigkeit über verschiedene Domänen hinweg zu verbessern.</p>\n\n<p>Indem Sie den Schritten und Code-Snippets in diesem Beitrag folgen, können Sie Ihr eigenes hybrides Suchsystem implementieren, das auf die spezifischen Anforderungen Ihrer E-Commerce-Website zugeschnitten ist. Beginnen Sie noch heute mit der Erkundung von Pinecone und verbessern Sie Ihre E-Commerce-Sucherfahrung!</p>\n\n<h2>Referenzen</h2>\n\n<ul>\n<li><a href=\"https://colab.research.google.com/github/pinecone-io/examples/blob/master/search/hybrid-search/ecommerce-search/ecommerce-search.ipynb\">Ecommerce Search using Hybrid Search Techniques in Pinecone (Google Colab Notebook)</a>: Ein praktischer Leitfaden, der die Implementierung der E-Commerce-Suche mit Pinecones hybriden Suchtechniken zeigt.</li>\n<li><a href=\"https://docs.pinecone.io/docs/ecommerce-search\">Pinecone Ecommerce Search Documentation</a>: Offizielle Pinecone-Dokumentation für den Aufbau von E-Commerce-Suchsystemen.</li>\n<li><a href=\"https://colab.research.google.com/github/pinecone-io/examples/blob/master/pinecone/sparse/bm25/bm25-vector-generation.ipynb\">BM25 Vector Generation using Pinecone (Google Colab Notebook)</a>: Ein Leitfaden zur Generierung von BM25-Sparse-Vektoren mit Pinecone.</li>\n<li><a href=\"https://github.com/pinecone-io/pinecone-text\">Pinecone Text Repository on GitHub</a>: Eine Sammlung von Textverarbeitungs- und Vektorgenerierungsressourcen mit Pinecone.</li>\n<li><a href=\"https://www.pinecone.io/learn/hybrid-search-intro/\">Introduction to Hybrid Search on Pinecone's Website</a>: Ein Überblick über die hybride Suche, ihre Vorteile und Anwendungsfälle im Kontext der Fähigkeiten von Pinecone.</li>\n</ul>",
  "source_hash": "sha256:14601d746f122e4e17ae78f475838ea1679e3865f9f52de9e7fc610d6b5fb139",
  "model": "claude-sonnet-4-5-20250929",
  "generated_at": "2026-01-01T23:58:28.651800+00:00"
}