{
  "title": "Hybrid-Suche für E-Commerce mit Pinecone und LLMs",
  "excerpt": "Erfahren Sie, wie Sie ein leistungsstarkes Hybrid-Suchsystem für E-Commerce-Anwendungen aufbauen, indem Sie traditionelle Information-Retrieval-Methoden mit Machine-Learning-Modellen wie Language Models (LLMs) und Pinecone, einer verwalteten Vektordatenbank, kombinieren. Entdecken Sie die Vorteile der Hybrid-Suche für E-Commerce, einschließlich verbesserter Suchrelevanz, Personalisierung, Handhabung von Long-Tail-Anfragen und einfacherer Infrastrukturverwaltung.",
  "content_html": "<p>Die Suche und das Auffinden relevanter Produkte ist eine kritische Komponente einer E-Commerce-Website. Schnelle und präzise Suchergebnisse können den Unterschied zwischen hoher Benutzerzufriedenheit und Benutzerfrust ausmachen. Mit den jüngsten Fortschritten im Bereich des natürlichen Sprachverständnisses und der Vektorsuchtechnologien sind verbesserte Suchsysteme zugänglicher und effizienter geworden, was zu besseren Benutzererfahrungen und verbesserten Konversionsraten führt.</p>\n\n<p>In diesem Blogbeitrag werden wir untersuchen, wie man ein Hybrid-Suchsystem für E-Commerce mit Pinecone, einer leistungsstarken Vektorsuchmaschine, und fein abgestimmten domänenspezifischen Sprachmodellen implementiert. Am Ende dieses Beitrags werden Sie nicht nur ein fundiertes Verständnis der Hybrid-Suche haben, sondern auch eine praktische Schritt-für-Schritt-Anleitung zur Implementierung.</p>\n\n<h2>Was ist Hybrid-Suche?</h2>\n\n<img src=\"/assets/images/pinecone_hybrid_index.jpg\" alt=\"Pinecone Hybrid Index\" class=\"post-img\" width=\"2360\" height=\"921\" />\n<span class=\"post-img-caption\">Überblick über einen einfachen Pinecone Hybrid Index</span>\n\n<p>Bevor wir uns mit der Implementierung befassen, sollten wir kurz verstehen, was Hybrid-Suche bedeutet. Hybrid-Suche ist ein Ansatz, der die Stärken sowohl der traditionellen Suche (Sparse-Vektorsuche) als auch der Vektorsuche (Dense-Vektorsuche) kombiniert, um eine bessere Suchleistung über eine Vielzahl von Domänen hinweg zu erzielen.</p>\n\n<p>Die Dense-Vektorsuche extrahiert hochwertige Vektor-Embeddings aus Textdaten und führt eine Ähnlichkeitssuche durch, um relevante Dokumente zu finden. Sie hat jedoch oft Schwierigkeiten mit domänenfremden Daten, wenn sie nicht auf domänenspezifischen Datensätzen fein abgestimmt ist.</p>\n\n<p>Andererseits verwendet die traditionelle Suche Sparse-Vektordarstellungen wie Term Frequency-Inverse Document Frequency (TF-IDF) oder BM25 und erfordert keine domänenspezifische Feinabstimmung. Während sie neue Domänen handhaben kann, ist ihre Leistung durch ihre Unfähigkeit, semantische Beziehungen zwischen Wörtern zu verstehen, begrenzt und es fehlt ihr die Intelligenz des Dense Retrieval.</p>\n\n<p>Die Hybrid-Suche versucht, die Schwächen beider Ansätze zu mildern, indem sie sie in einem einzigen System kombiniert und dabei das Leistungspotenzial der Dense-Vektorsuche und die Zero-Shot-Anpassungsfähigkeit der traditionellen Suche nutzt.</p>\n\n<p>Nachdem wir nun ein grundlegendes Verständnis der Hybrid-Suche haben, tauchen wir in ihre Implementierung ein.</p>\n\n<h2>Aufbau eines Hybrid-Suchsystems</h2>\n\n<p>Wir werden die folgenden Schritte zur Implementierung eines Hybrid-Suchsystems behandeln:</p>\n\n<ol>\n<li>Nutzung domänenspezifischer Sprachmodelle</li>\n<li>Erstellung von Sparse- und Dense-Vektoren</li>\n<li>Einrichtung von Pinecone</li>\n<li>Implementierung der Hybrid-Such-Pipeline</li>\n<li>Durchführung von Abfragen und Abstimmung von Parametern</li>\n</ol>\n\n<h3>1. Nutzung domänenspezifischer Sprachmodelle</h3>\n\n<p>In den letzten Jahren sind großangelegte vortrainierte Sprachmodelle wie OpenAI's GPT und Cohere für eine Vielzahl von Aufgaben, einschließlich natürlichem Sprachverständnis und -generierung, zunehmend populär geworden. Diese Modelle können auf domänenspezifischen Daten fein abgestimmt werden, um ihre Leistung zu verbessern und sich an spezifische Aufgaben anzupassen, wie z.B. die E-Commerce-Produktsuche.</p>\n\n<p>In unserem Beispiel werden wir ein fein abgestimmtes domänenspezifisches Sprachmodell verwenden, um Dense-Vektor-Embeddings für Produkte und Anfragen zu generieren. Sie können jedoch auch andere Modelle wählen oder sogar Ihre eigenen benutzerdefinierten Embeddings basierend auf Ihrer spezifischen Domäne erstellen.</p>\n\n<pre><code class=\"language-python\">import torch\nfrom transformers import AutoTokenizer, AutoModel\n\n# Laden eines vortrainierten domänenspezifischen Sprachmodells\nmodel_name = \"your-domain-specific-model\"\ntokenizer = AutoTokenizer.from_pretrained(model_name)\nmodel = AutoModel.from_pretrained(model_name)\n\n# Generierung von Dense-Vektor-Embeddings für eine Produktbeschreibung\ntext = \"Nike Air Max sports shoes for men\"\ninputs = tokenizer(text, return_tensors=\"pt\")\nwith torch.no_grad():\n    outputs = model(**inputs)\n    dense_embedding = outputs.last_hidden_state.mean(dim=1).numpy()\n</code></pre>\n\n<h3>2. Erstellung von Sparse- und Dense-Vektoren</h3>\n\n<p>Die Hybrid-Suche erfordert sowohl Sparse- als auch Dense-Vektordarstellungen für unsere E-Commerce-Daten. Wir werden nun beschreiben, wie diese Vektoren generiert werden.</p>\n\n<h4>Sparse-Vektoren</h4>\n\n<p>Sparse-Vektordarstellungen wie TF-IDF oder BM25 können mit Standard-Textverarbeitungstechniken wie Tokenisierung, Stopwort-Entfernung und Stemming erstellt werden. Ein Beispiel für die Generierung von Sparse-Vektoren kann mit einer Vokabularmatrix erreicht werden.</p>\n\n<pre><code class=\"language-python\"># Diese Funktion generiert Sparse-Vektordarstellungen einer Liste von Produktbeschreibungen\ndef generate_sparse_vectors(text):\n    '''Generiert Sparse-Vektordarstellungen für eine Liste von Produktbeschreibungen\n\n    Args:\n        text (list): Eine Liste von Produktbeschreibungen\n\n    Returns:\n        sparse_vector (dict): Ein Dictionary von Indizes und Werten\n    '''\n    sparse_vector = bm25.encode_queries(text)\n    return sparse_vector\n\nfrom pinecone_text.sparse import BM25Encoder\n\n# Erstellen des BM25-Encoders und Anpassen der Daten\nbm25 = BM25Encoder()\nbm25.fit(new_df.full_data)\n\n# Erstellen der Sparse-Vektoren\nsparse_vectors = []\nfor product_description in product_descriptions:\n    sparse_vectors.append(generate_sparse_vectors(text=product_description))\n</code></pre>\n\n<h4>Dense-Vektoren</h4>\n\n<p>Dense-Vektordarstellungen können mit vortrainierten oder benutzerdefinierten domänenspezifischen Sprachmodellen generiert werden. In unserem vorherigen Beispiel haben wir ein domänenspezifisches Sprachmodell verwendet, um Dense-Vektor-Embeddings für eine Produktbeschreibung zu generieren.</p>\n\n<pre><code class=\"language-python\">def generate_dense_vector(text):\n    '''Generiert Dense-Vektor-Embeddings für eine Liste von Produktbeschreibungen\n\n    Args:\n        text (list): Eine Liste von Produktbeschreibungen\n\n    Returns:\n        dense_embedding (np.array): Ein numpy-Array von Dense-Vektor-Embeddings\n    '''\n    # Tokenisierung des Textes und Konvertierung in PyTorch-Tensoren\n    inputs = tokenizer(text, return_tensors=\"pt\")\n    # Generierung der Embeddings mit dem vortrainierten Modell\n    with torch.no_grad():\n        outputs = model(**inputs)\n        dense_vector = outputs.last_hidden_state.mean(dim=1).numpy()\n    return dense_vector\n\n# Generierung von Dense-Vektor-Embeddings für eine Liste von Produktbeschreibungen\ndense_vectors = []\nfor product_description in product_descriptions:\n    dense_vectors.append(generate_dense_vector(text=product_description))\n</code></pre>\n\n<h3>3. Einrichtung von Pinecone</h3>\n\n<p>Pinecone ist eine leistungsstarke Vektorsuchmaschine, die Hybrid-Suche unterstützt. Sie ermöglicht die Erstellung eines einzigen Index für sowohl Sparse- als auch Dense-Vektoren und verarbeitet nahtlos Suchanfragen über verschiedene Datenmodalitäten hinweg.</p>\n\n<p>Um Pinecone zu verwenden, müssen Sie sich für ein Konto anmelden, den Pinecone-Client installieren und Ihren API-Schlüssel und Ihre Umgebung einrichten.</p>\n\n<pre><code class=\"language-python\"># Erstellen eines Pinecone Hybrid-Such-Index\nimport pinecone\n\npinecone.init(\n    api_key=\"YOUR_API_KEY\",  # app.pinecone.io\n    environment=\"YOUR_ENV\"  # neben dem API-Schlüssel in der Konsole zu finden\n)\n\n# Erstellen eines Pinecone Hybrid-Such-Index\nindex_name = \"ecommerce-hybrid-search\"\npinecone.create_index(\n    index_name = index_name,\n    dimension = MODEL_DIMENSION,  # Dimensionalität des Dense-Modells\n    metric = \"dotproduct\"\n)\n# Verbindung zum Index herstellen\nindex = pinecone.Index(index_name=index_name)\n# Index-Statistiken anzeigen\nindex.describe_index_stats()\n</code></pre>\n\n<h3>4. Implementierung der Hybrid-Such-Pipeline</h3>\n\n<p>Mit unseren generierten Sparse- und Dense-Vektoren und der eingerichteten Pinecone-Umgebung können wir nun eine Hybrid-Such-Pipeline aufbauen. Diese Pipeline umfasst die folgenden Schritte:</p>\n\n<ol>\n<li>Hinzufügen von Produktdaten zum Pinecone-Index</li>\n<li>Abrufen von Ergebnissen unter Verwendung sowohl von Sparse- als auch Dense-Vektoren</li>\n</ol>\n\n<pre><code class=\"language-python\">def add_product_data_to_index(product_ids, sparse_vectors, dense_vectors, metadata=None):\n    \"\"\"Fügt Produktdaten zum Pinecone-Index hinzu.\n\n    Args:\n        product_ids (`list` of `str`): Produkt-IDs.\n        sparse_vectors (`list` of `list` of `float`): Sparse-Vektoren.\n        dense_vectors (`list` of `list` of `float`): Dense-Vektoren.\n        metadata (`list` of `list` of `str`): Optionale Metadaten.\n\n    Returns:\n        None\n    \"\"\"\n    batch_size = 32\n\n    # Durchlaufen der Produkt-IDs in Batches.\n    for i in range(0, len(product_ids), batch_size):\n        i_end = min(i + batch_size, len(product_ids))\n        ids = product_ids[i:i_end]\n        sparse_batch = sparse_vectors[i:i_end]\n        dense_batch = dense_vectors[i:i_end]\n        meta_batch = metadata[i:i_end] if metadata else []\n\n        vectors = []\n        for _id, sparse, dense, meta in zip(ids, sparse_batch, dense_batch, meta_batch):\n            vectors.append({\n                'id': _id,\n                'sparse_values': sparse,\n                'values': dense,\n                'metadata': meta\n            })\n\n        # Einfügen der Vektoren in den Pinecone-Index.\n        index.upsert(vectors=vectors)\n\nadd_product_data_to_index(product_ids, sparse_vectors, dense_vectors)\n</code></pre>\n\n<p>Nachdem unsere Daten indexiert sind, können wir Hybrid-Suchanfragen durchführen.</p>\n\n<h3>5. Durchführung von Abfragen und Abstimmung von Parametern</h3>\n\n<img src=\"/assets/images/pinecone_hybrid_query.jpg\" alt=\"Pinecone Hybrid Query\" class=\"post-img\" width=\"2360\" height=\"892\" />\n<span class=\"post-img-caption\">Überblick über eine einfache Pinecone Hybrid-Abfrage</span>\n\n<p>Um Hybrid-Suchanfragen durchzuführen, erstellen wir eine Funktion, die eine Anfrage, die Anzahl der Top-Ergebnisse und einen Alpha-Parameter zur Steuerung der Gewichtung zwischen Dense- und Sparse-Vektorsuche-Scores entgegennimmt.</p>\n\n<pre><code class=\"language-python\">def hybrid_scale(dense, sparse, alpha: float):\n    \"\"\"Hybrid-Vektorskalierung unter Verwendung einer konvexen Kombination\n\n    alpha * dense + (1 - alpha) * sparse\n\n    Args:\n        dense: Array von Floats\n        sparse: ein Dict von `indices` und `values`\n        alpha: Float zwischen 0 und 1, wobei 0 == nur sparse\n               und 1 == nur dense\n    \"\"\"\n    if alpha &lt; 0 or alpha &gt; 1:\n        raise ValueError(\"Alpha muss zwischen 0 und 1 liegen\")\n    # Skalierung von Sparse- und Dense-Vektoren zur Erstellung von Hybrid-Such-Vektoren\n    hsparse = {\n        'indices': sparse['indices'],\n        'values':  [v * (1 - alpha) for v in sparse['values']]\n    }\n    hdense = [v * alpha for v in dense]\n    return hdense, hsparse\n\ndef search_products(query, top_k=10, alpha=0.5):\n    # Generierung des Sparse-Abfragevektors\n    sparse_query_vector = generate_sparse_vector(query)\n\n    # Generierung des Dense-Abfragevektors\n    dense_query_vector = generate_dense_vector(query)\n\n    # Berechnung des Hybrid-Abfragevektors\n    dense_query_vector, sparse_query_vector = hybrid_scale(dense_query_vector, sparse_query_vector, alpha)\n\n    # Produktsuche mit Pinecone\n    results = index.query(\n        vector=dense_query_vector,\n        sparse_vector=sparse_query_vector,\n        top_k=top_k\n    )\n\n    return results\n</code></pre>\n\n<p>Wir können diese Funktion dann verwenden, um nach relevanten Produkten in unserem E-Commerce-Datensatz zu suchen.</p>\n\n<pre><code class=\"language-python\">query = \"running shoes for women\"\nresults = search_products(query, top_k=5)\n\nfor result in results:\n    print(result['id'], result['metadata']['product_name'], result['score'])\n</code></pre>\n\n<p>Das Experimentieren mit verschiedenen Werten für den Alpha-Parameter hilft Ihnen, die optimale Balance zwischen Sparse- und Dense-Vektorsuche für Ihre spezifische Domäne zu finden.</p>\n\n<h2>Fazit</h2>\n\n<p>In diesem Blogbeitrag haben wir demonstriert, wie man ein Hybrid-Suchsystem für E-Commerce mit Pinecone und domänenspezifischen Sprachmodellen aufbaut. Die Hybrid-Suche ermöglicht es uns, die Stärken sowohl der traditionellen Suche als auch der Vektorsuche zu kombinieren und die Suchleistung und Anpassungsfähigkeit über verschiedene Domänen hinweg zu verbessern.</p>\n\n<p>Indem Sie den Schritten und Code-Snippets in diesem Beitrag folgen, können Sie Ihr eigenes Hybrid-Suchsystem implementieren, das auf die spezifischen Anforderungen Ihrer E-Commerce-Website zugeschnitten ist. Beginnen Sie noch heute mit der Erkundung von Pinecone und verbessern Sie Ihre E-Commerce-Sucherfahrung!</p>\n\n<h2>Referenzen</h2>\n\n<ul>\n<li><a href=\"https://colab.research.google.com/github/pinecone-io/examples/blob/master/search/hybrid-search/ecommerce-search/ecommerce-search.ipynb\">Ecommerce Search using Hybrid Search Techniques in Pinecone (Google Colab Notebook)</a>: Ein praktischer Leitfaden, der die Implementierung der E-Commerce-Suche mit Pinecones Hybrid-Suchtechniken zeigt.</li>\n<li><a href=\"https://docs.pinecone.io/docs/ecommerce-search\">Pinecone Ecommerce Search Documentation</a>: Offizielle Pinecone-Dokumentation zum Aufbau von E-Commerce-Suchsystemen.</li>\n<li><a href=\"https://colab.research.google.com/github/pinecone-io/examples/blob/master/pinecone/sparse/bm25/bm25-vector-generation.ipynb\">BM25 Vector Generation using Pinecone (Google Colab Notebook)</a>: Ein Leitfaden zur Generierung von BM25-Sparse-Vektoren mit Pinecone.</li>\n<li><a href=\"https://github.com/pinecone-io/pinecone-text\">Pinecone Text Repository on GitHub</a>: Eine Sammlung von Textverarbeitungs- und Vektorgenerierungsressourcen mit Pinecone.</li>\n<li><a href=\"https://www.pinecone.io/learn/hybrid-search-intro/\">Introduction to Hybrid Search on Pinecone's Website</a>: Ein Überblick über Hybrid-Suche, ihre Vorteile und Anwendungsfälle im Kontext der Fähigkeiten von Pinecone.</li>\n</ul>",
  "source_hash": "sha256:c8b3789c888127b9f8404365e651e80624c4177f346d2aef54a3b185e2cd138b",
  "model": "claude-sonnet-4-5-20250929",
  "generated_at": "2026-01-15T20:04:25.514828+00:00"
}