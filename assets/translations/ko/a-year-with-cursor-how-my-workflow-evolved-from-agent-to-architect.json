{
  "title": "Cursor와 함께한 1년: 에이전트에서 아키텍트로 진화한 나의 워크플로우",
  "excerpt": "Cursor와 함께한 나의 여정은 도구 자체의 성숙 과정을 반영합니다: 단순한 에이전트에서 정교한 아키텍처 파트너로. 이 글은 @ 멘션, MCP, Plan Mode, 그리고 커스텀 명령어를 통해 내 워크플로우가 어떻게 진화했는지 상세히 다룹니다.",
  "content_html": "<p>Cursor를 주요 IDE로 사용한 지 1년이 넘었고, 이 도구가 내 업무에 미친 영향은 과장하기 어려울 정도입니다. Dylog에서 대화형 AI 플랫폼을 구축하는 머신러닝 엔지니어로서, 그리고 개인 프로젝트에서 에이전틱 인프라를 실험하면서, 저는 AI 네이티브 개발의 진화를 직접 경험했습니다. Cursor와 함께한 나의 여정은 도구 자체의 성숙 과정을 반영합니다: 단순한 에이전트에서 정교한 아키텍처 파트너로.</p>\n\n<p>이 글은 그 여정에 대한 회고이며, 내 워크플로우가 어떻게 진화했는지, 그리고 Plan Mode, 커스텀 명령어, 컨텍스트 엔지니어링의 강력한 조합을 통해 더 빠르고, 더 스마트하게, 더 명확하게 개발하는 방법을 상세히 다룹니다.</p>\n\n<h2>1단계: 에이전트가 운전대를 잡다</h2>\n\n<p>처음 시작했을 때, 제 사용법은 단순했습니다. Cursor를 강력한 자동완성 도구처럼 다뤘죠. 주석을 작성하고 <code>Cmd+K</code>를 누르면 에이전트가 코드를 생성했습니다. 마법 같았지만, 동시에 블랙박스이기도 했습니다. 저는 승객이었고, 에이전트가 운전하고 있었습니다.</p>\n\n<p>그러다 <strong>@ 멘션</strong>이 등장했습니다. 이것은 에이전트에게 실제 컨텍스트를 제공하는 첫 경험이었습니다. 코드베이스를 이해하기를 바라는 대신, 무엇을 봐야 하는지 명시적으로 알려줄 수 있었습니다:</p>\n\n<ul>\n<li><code>@file</code> 특정 파일 참조</li>\n<li><code>@folder</code> 전체 디렉토리 포함</li>\n<li><code>@codebase</code> 전체 프로젝트 검색</li>\n<li><code>@web</code> 외부 문서 가져오기</li>\n<li><code>@docs</code> 라이브러리 공식 문서 참조</li>\n</ul>\n\n<p>이것은 엄청난 도약이었습니다. 갑자기 에이전트는 추측하는 것이 아니라, 제가 가진 것과 동일한 컨텍스트로 작업하게 되었습니다. \"이 함수를 <code>@file:utils/helpers.ts</code>의 패턴에 맞춰 리팩토링해줘\"라고 말하면 실제로 이해했습니다.</p>\n\n<p><img src=\"/assets/images/cursor-at-mentions.png\" alt=\"Cursor @ mention context\" class=\"post-img\" />\n<span class=\"post-img-caption\">Cursor의 @ 멘션 드롭다운, @file, @folder, @codebase, @web, @docs와 같은 컨텍스트 옵션을 보여주며 명시적인 컨텍스트 제어를 가능하게 합니다</span></p>\n\n<p>하지만 더 나은 컨텍스트를 가지고도, 생성, 디버깅, 재생성의 루프에 빠지곤 했습니다. 에이전트는 더 큰 작업에 대한 아키텍처 비전이 부족했습니다.</p>\n\n<h2>2단계: MCP가 모든 것을 바꾸다</h2>\n\n<p><strong>Model Context Protocol (MCP)</strong>의 도입은 본격적인 전환점이었습니다. MCP를 통해 Cursor를 외부 도구와 데이터 소스에 연결할 수 있게 되면서, 에이전트는 단순한 코드 생성기에서 내 전체 워크플로우에 접근할 수 있는 진정한 어시스턴트로 변모했습니다.</p>\n\n<p>다음과 같은 MCP를 통합하기 시작했습니다:</p>\n\n<ul>\n<li><strong>GitHub</strong> 이슈와 PR을 컨텍스트로 직접 가져오기</li>\n<li><strong>Linear</strong> 작업 관리 통합</li>\n<li><strong>Slack</strong> 팀 커뮤니케이션 컨텍스트</li>\n<li><strong>커스텀 MCP</strong> 내부 API와 데이터베이스용</li>\n</ul>\n\n<p>MCP를 통해 \"Linear 이슈 #234에 설명된 기능을 구현해줘\"라고 말하면 에이전트가 이슈를 가져오고, 요구사항을 이해하고, 개발을 시작했습니다. 더 이상 코드만의 문제가 아니었습니다. 전체 개발 생태계를 연결하는 것이었습니다.</p>\n\n<p><img src=\"/assets/images/cursor-mcp-integrations.png\" alt=\"MCP integrations in Cursor\" class=\"post-img\" />\n<span class=\"post-img-caption\">GitHub, Linear, Slack, 그리고 개발 생태계 전반에 걸쳐 Cursor의 기능을 확장하는 커스텀 서버와 같은 연결된 통합을 보여주는 MCP 구성 패널</span></p>\n\n<h2>3단계: 플래너의 부상</h2>\n\n<p><strong>Plan Mode</strong>의 도입은 다음 게임 체인저였습니다. AI와 협업하고 있다고 느낀 첫 순간이었습니다. 단순히 위임하는 것이 아니라요. Ray Fernando 같은 개발자들의 워크플로우에서 영감을 받아, 2단계 프로세스를 사용하기 시작했습니다:</p>\n\n<ol>\n<li><p><strong>Opus로 계획하기:</strong> Claude Opus 같은 강력한 모델을 사용해 상세한 단계별 구현 계획을 생성했습니다. 고수준 목표를 제공하면, 파일명, 함수 시그니처, 로직을 포함한 구체적인 작업 시리즈로 분해했습니다.</p></li>\n<li><p><strong>Sonnet/GPT로 실행하기:</strong> 그런 다음 그 계획을 Sonnet이나 GPT-5.2 같은 더 빠르고 저렴한 모델에 넘겨 각 단계를 실행했습니다. 저렴한 모델은 뛰어난 아키텍트일 필요가 없었습니다. 단지 성실한 빌더면 충분했습니다.</p></li>\n</ol>\n\n<p>이 워크플로우는 엄청난 개선이었습니다. \"무엇을\"과 \"어떻게\"를 분리했고, 코드가 작성되기 전에 검토하고 승인할 수 있는 산출물—계획—을 제공했습니다. 토큰 비용도 크게 절감했습니다.</p>\n\n<p><img src=\"/assets/images/cursor-plan-mode.png\" alt=\"Cursor Plan Mode workflow\" class=\"post-img\" />\n<span class=\"post-img-caption\">왼쪽의 <code>.cursor/plans/</code> 파일에 있는 상세한 구현 계획과 오른쪽의 해당 생성 코드를 보여주는 분할 뷰, 아키텍처와 실행의 분리를 보여줍니다</span></p>\n\n<h2>4단계: 아키텍트의 등장 (명령어 + 계획)</h2>\n\n<p>이것이 제가 현재 있는 곳입니다. Plan Mode는 여전히 워크플로우의 중심이지만, 프로세스를 미세 조정하고 아키텍처 원칙을 IDE에 직접 구워넣기 위해 <strong>커스텀 명령어</strong>와 <strong>규칙</strong> 세트를 추가했습니다.</p>\n\n<h3>현재 설정</h3>\n\n<p><strong>규칙 (<code>.cursorrules</code>):</strong> 코딩 표준, 선호하는 패턴, 아키텍처 제약을 정의하는 규칙 세트가 있습니다. 에이전트는 모든 작업 전에 이것을 읽어 코드베이스 전반의 일관성을 보장합니다.</p>\n\n<p><strong>커스텀 명령어:</strong> 가장 일반적인 워크플로우를 래핑하는 명령어를 만들었습니다:</p>\n\n<ul>\n<li><code>/plan</code> - Opus를 사용해 상세한 구현 계획 생성</li>\n<li><code>/refactor</code> - 파일을 가져와 지시사항에 따라 리팩토링</li>\n<li><code>/test</code> - 주어진 함수에 대한 테스트 스위트 생성</li>\n<li><code>/review</code> - 규칙에 따라 코드를 검토하고 개선사항 제안</li>\n</ul>\n\n<p><strong>대기 메시지:</strong> 에이전트가 작업하는 동안 <code>Ctrl+Enter</code>를 사용해 후속 지시사항을 대기열에 넣습니다. 이를 통해 현재 작업을 중단하지 않고 앞서 생각하며 추진력을 유지할 수 있습니다.</p>\n\n<p><img src=\"/assets/images/cursor-custom-commands.png\" alt=\"Cursor custom commands and rules\" class=\"post-img\" />\n<span class=\"post-img-caption\">/plan, /refactor, /test, /review와 같은 커스텀 명령어를 보여주는 Cursor 명령 팔레트와 코딩 표준 및 아키텍처 제약을 정의하는 <code>.cursorrules</code> 파일</span></p>\n\n<h2>진화 한눈에 보기</h2>\n\n<table>\n<thead>\n<tr>\n<th>단계</th>\n<th>핵심 기능</th>\n<th>변화</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>Agent Mode + @ 멘션</td>\n<td>컨텍스트가 추측이 아닌 명시적으로 변경</td>\n</tr>\n<tr>\n<td>2</td>\n<td>MCP 통합</td>\n<td>외부 도구와 데이터 접근 가능</td>\n</tr>\n<tr>\n<td>3</td>\n<td>Plan Mode</td>\n<td>아키텍처와 실행 분리</td>\n</tr>\n<tr>\n<td>4</td>\n<td>명령어 + 규칙</td>\n<td>워크플로우가 반복 가능하고 개인화됨</td>\n</tr>\n</tbody>\n</table>\n\n<h2>왜 이것이 중요한가</h2>\n\n<p>에이전트에서 아키텍트로의 이 진화는 단순한 개인 생산성 해킹 이상입니다. 소프트웨어 개발의 미래를 엿보는 것입니다. 우리는 코드를 작성하는 세계에서 <strong>시스템을 설명하는</strong> 세계로 이동하고 있습니다. 우리의 역할은 아키텍트가 되어 청사진을 정의하고, 에이전트가 건설하도록 하는 것입니다.</p>\n\n<p>Cursor는 제가 사용한 다른 어떤 도구보다 이러한 변화를 이해합니다. 단순히 코드를 생성하는 것이 아니라, 복잡성을 관리하고, 컨텍스트를 유지하며, 개발자에게 이전에는 상상할 수 없었던 규모로 개발할 수 있는 레버리지를 제공하는 것입니다.</p>\n\n<p>여전히 AI를 단순한 코드 생성기로 사용하고 있다면, @ 멘션, MCP, Plan Mode, 커스텀 명령어를 탐색해보시길 권장합니다. AI를 사용하는 개발자에서 AI를 지휘하는 아키텍트로 변모하는 여정이 될 것입니다.</p>\n\n<p>기억하세요: 우리는 더 이상 코드를 작성하는 것이 아니라, 시스템을 설계하고 있습니다.</p>",
  "source_hash": "sha256:662561f10cc6e2a91c66508ff149182da2e11a387f342090ce2e43b96d291d1b",
  "model": "claude-sonnet-4-5-20250929",
  "generated_at": "2026-01-05T01:55:07.110239+00:00"
}