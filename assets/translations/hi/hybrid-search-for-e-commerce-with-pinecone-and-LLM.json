{
  "title": "Pinecone और LLMs के साथ E-Commerce के लिए Hybrid Search",
  "excerpt": "पारंपरिक सूचना पुनर्प्राप्ति विधियों को Language Models (LLMs) और Pinecone जैसे managed vector database के साथ मिलाकर e-commerce अनुप्रयोगों के लिए एक शक्तिशाली hybrid search प्रणाली बनाने का तरीका जानें। E-commerce के लिए hybrid search के लाभों को खोजें, जिनमें बेहतर खोज प्रासंगिकता, वैयक्तिकरण, long-tail queries को संभालना और सरल infrastructure प्रबंधन शामिल हैं।",
  "content_html": "<p>संबंधित उत्पादों को खोजना और ढूंढना e-commerce वेबसाइट का एक महत्वपूर्ण घटक है। तेज़ और सटीक खोज परिणाम प्रदान करना उच्च उपयोगकर्ता संतुष्टि और उपयोगकर्ता निराशा के बीच अंतर बना सकता है। प्राकृतिक भाषा समझ और vector search प्रौद्योगिकियों में हाल की प्रगति के साथ, उन्नत खोज प्रणालियाँ अधिक सुलभ और कुशल हो गई हैं, जिससे बेहतर उपयोगकर्ता अनुभव और बेहतर conversion दरें प्राप्त हुई हैं।</p>\n\n<p>इस ब्लॉग पोस्ट में, हम Pinecone, एक उच्च-प्रदर्शन vector search engine, और fine-tuned domain-specific language models का उपयोग करके e-commerce के लिए एक hybrid search प्रणाली को लागू करने का तरीका जानेंगे। इस पोस्ट के अंत तक, आपको न केवल hybrid search की मजबूत समझ होगी बल्कि इसे लागू करने के लिए एक व्यावहारिक step-by-step मार्गदर्शिका भी मिलेगी।</p>\n\n<h2>Hybrid Search क्या है?</h2>\n\n<img src=\"/assets/images/pinecone_hybrid_index.jpg\" alt=\"Pinecone Hybrid Index\" class=\"post-img\" />\n<span class=\"post-img-caption\">साधारण Pinecone Hybrid Index का उच्च-स्तरीय दृश्य</span>\n\n<p>कार्यान्वयन में जाने से पहले, आइए जल्दी से समझें कि hybrid search का क्या मतलब है। Hybrid search एक ऐसा दृष्टिकोण है जो पारंपरिक खोज (sparse vector search) और vector search (dense vector search) दोनों की ताकत को जोड़कर विभिन्न प्रकार के डोमेन में बेहतर खोज प्रदर्शन प्राप्त करता है।</p>\n\n<p>Dense vector search टेक्स्ट डेटा से उच्च-गुणवत्ता वाले vector embeddings निकालता है और संबंधित दस्तावेज़ों को खोजने के लिए similarity search करता है। हालांकि, जब इसे domain-specific datasets पर fine-tuned नहीं किया जाता है, तो यह अक्सर out-of-domain डेटा के साथ संघर्ष करता है।</p>\n\n<p>दूसरी ओर, पारंपरिक खोज sparse vector प्रतिनिधित्व का उपयोग करती है, जैसे term frequency-inverse document frequency (TF-IDF) या BM25, और इसे किसी domain-specific fine-tuning की आवश्यकता नहीं होती है। जबकि यह नए डोमेन को संभाल सकता है, इसका प्रदर्शन शब्दों के बीच semantic संबंधों को समझने में असमर्थता से सीमित है और dense retrieval की बुद्धिमत्ता का अभाव है।</p>\n\n<p>Hybrid search दोनों दृष्टिकोणों की कमजोरियों को कम करने की कोशिश करता है, उन्हें एक ही प्रणाली में मिलाकर, dense vector search की प्रदर्शन क्षमता और पारंपरिक खोज की zero-shot अनुकूलनशीलता का लाभ उठाता है।</p>\n\n<p>अब जब हमारे पास hybrid search की बुनियादी समझ है, आइए इसके कार्यान्वयन में गहराई से जाएं।</p>\n\n<h2>Hybrid Search प्रणाली का निर्माण</h2>\n\n<p>हम hybrid search प्रणाली को लागू करने के लिए निम्नलिखित चरणों को कवर करेंगे:</p>\n\n<ol>\n<li>Domain-Specific Language Models का लाभ उठाना</li>\n<li>Sparse और Dense Vectors बनाना</li>\n<li>Pinecone को सेट करना</li>\n<li>Hybrid Search Pipeline को लागू करना</li>\n<li>Queries बनाना और Parameters को ट्यून करना</li>\n</ol>\n\n<h3>1. Domain-Specific Language Models का लाभ उठाना</h3>\n\n<p>हाल के वर्षों में, OpenAI के GPT और Cohere जैसे बड़े पैमाने के pre-trained language models प्राकृतिक भाषा समझ और generation सहित विभिन्न कार्यों के लिए तेजी से लोकप्रिय हो गए हैं। इन मॉडलों को उनके प्रदर्शन को बेहतर बनाने और e-commerce उत्पाद खोज जैसे विशिष्ट कार्यों के लिए अनुकूलित करने के लिए domain-specific डेटा पर fine-tuned किया जा सकता है।</p>\n\n<p>हमारे उदाहरण में, हम उत्पादों और queries के लिए dense vector embeddings उत्पन्न करने के लिए एक fine-tuned domain-specific language model का उपयोग करेंगे। हालांकि, आप अपने विशिष्ट डोमेन के आधार पर अन्य मॉडल चुन सकते हैं या यहां तक कि अपने स्वयं के custom embeddings भी बना सकते हैं।</p>\n\n<pre><code class=\"language-python\">import torch\nfrom transformers import AutoTokenizer, AutoModel\n\n# एक pre-trained domain-specific language model लोड करें\nmodel_name = \"your-domain-specific-model\"\ntokenizer = AutoTokenizer.from_pretrained(model_name)\nmodel = AutoModel.from_pretrained(model_name)\n\n# उत्पाद विवरण के लिए dense vector embeddings उत्पन्न करें\ntext = \"Nike Air Max sports shoes for men\"\ninputs = tokenizer(text, return_tensors=\"pt\")\nwith torch.no_grad():\n    outputs = model(**inputs)\n    dense_embedding = outputs.last_hidden_state.mean(dim=1).numpy()\n</code></pre>\n\n<h3>2. Sparse और Dense Vectors बनाना</h3>\n\n<p>Hybrid search को हमारे e-commerce डेटा के लिए sparse और dense vector प्रतिनिधित्व दोनों की आवश्यकता होती है। अब हम वर्णन करेंगे कि इन vectors को कैसे उत्पन्न किया जाए।</p>\n\n<h4>Sparse Vectors</h4>\n\n<p>Sparse vector प्रतिनिधित्व, जैसे TF-IDF या BM25, मानक टेक्स्ट प्रोसेसिंग तकनीकों का उपयोग करके बनाए जा सकते हैं, जैसे tokenization, stopword removal, और stemming। Sparse vectors उत्पन्न करने का एक उदाहरण vocabulary matrix का उपयोग करके प्राप्त किया जा सकता है।</p>\n\n<pre><code class=\"language-python\"># यह फंक्शन उत्पाद विवरण की सूची के sparse vector प्रतिनिधित्व उत्पन्न करता है\ndef generate_sparse_vectors(text):\n    '''उत्पाद विवरण की सूची के लिए sparse vector प्रतिनिधित्व उत्पन्न करता है\n\n    Args:\n        text (list): उत्पाद विवरण की एक सूची\n\n    Returns:\n        sparse_vector (dict): indices और values का एक dictionary\n    '''\n    sparse_vector = bm25.encode_queries(text)\n    return sparse_vector\n\nfrom pinecone_text.sparse import BM25Encoder\n\n# BM25 encoder बनाएं और डेटा को fit करें\nbm25 = BM25Encoder()\nbm25.fit(new_df.full_data)\n\n# Sparse vectors बनाएं\nsparse_vectors = []\nfor product_description in product_descriptions:\n    sparse_vectors.append(generate_sparse_vectors(text=product_description))\n</code></pre>\n\n<h4>Dense Vectors</h4>\n\n<p>Dense vector प्रतिनिधित्व pre-trained या custom domain-specific language models का उपयोग करके उत्पन्न किए जा सकते हैं। हमारे पिछले उदाहरण में, हमने एक उत्पाद विवरण के लिए dense vector embeddings उत्पन्न करने के लिए एक domain-specific language model का उपयोग किया।</p>\n\n<pre><code class=\"language-python\">def generate_dense_vector(text):\n    '''उत्पाद विवरण की सूची के लिए dense vector embeddings उत्पन्न करता है\n\n    Args:\n        text (list): उत्पाद विवरण की एक सूची\n\n    Returns:\n        dense_embedding (np.array): dense vector embeddings का एक numpy array\n    '''\n    # टेक्स्ट को tokenize करें और PyTorch tensors में बदलें\n    inputs = tokenizer(text, return_tensors=\"pt\")\n    # Pre-trained model के साथ embeddings उत्पन्न करें\n    with torch.no_grad():\n        outputs = model(**inputs)\n        dense_vector = outputs.last_hidden_state.mean(dim=1).numpy()\n    return dense_vector\n\n# उत्पाद विवरण की सूची के लिए dense vector embeddings उत्पन्न करें\ndense_vectors = []\nfor product_description in product_descriptions:\n    dense_vectors.append(generate_dense_vector(text=product_description))\n</code></pre>\n\n<h3>3. Pinecone को सेट करना</h3>\n\n<p>Pinecone एक उच्च-प्रदर्शन vector search engine है जो hybrid search का समर्थन करता है। यह sparse और dense vectors दोनों के लिए एक single index बनाने में सक्षम बनाता है और विभिन्न डेटा modalities में search queries को सहजता से संभालता है।</p>\n\n<p>Pinecone का उपयोग करने के लिए, आपको एक खाता बनाना होगा, Pinecone client को install करना होगा, और अपनी API key और environment को सेट करना होगा।</p>\n\n<pre><code class=\"language-python\"># एक Pinecone hybrid search index बनाएं\nimport pinecone\n\npinecone.init(\n    api_key=\"YOUR_API_KEY\",  # app.pinecone.io\n    environment=\"YOUR_ENV\"  # console में api key के बगल में खोजें\n)\n\n# एक Pinecone hybrid search index बनाएं\nindex_name = \"ecommerce-hybrid-search\"\npinecone.create_index(\n    index_name = index_name,\n    dimension = MODEL_DIMENSION,  # dense model की dimensionality\n    metric = \"dotproduct\"\n)\n# index से कनेक्ट करें\nindex = pinecone.Index(index_name=index_name)\n# index stats देखें\nindex.describe_index_stats()\n</code></pre>\n\n<h3>4. Hybrid Search Pipeline को लागू करना</h3>\n\n<p>हमारे sparse और dense vectors उत्पन्न होने और Pinecone सेट होने के साथ, हम अब एक hybrid search pipeline बना सकते हैं। इस pipeline में निम्नलिखित चरण शामिल हैं:</p>\n\n<ol>\n<li>Pinecone index में उत्पाद डेटा जोड़ना</li>\n<li>Sparse और dense vectors दोनों का उपयोग करके परिणाम प्राप्त करना</li>\n</ol>\n\n<pre><code class=\"language-python\">def add_product_data_to_index(product_ids, sparse_vectors, dense_vectors, metadata=None):\n    \"\"\"Pinecone index में उत्पाद डेटा को upsert करता है।\n\n    Args:\n        product_ids (`list` of `str`): उत्पाद IDs।\n        sparse_vectors (`list` of `list` of `float`): Sparse vectors।\n        dense_vectors (`list` of `list` of `float`): Dense vectors।\n        metadata (`list` of `list` of `str`): वैकल्पिक metadata।\n\n    Returns:\n        None\n    \"\"\"\n    batch_size = 32\n\n    # Batches में उत्पाद IDs के माध्यम से loop करें।\n    for i in range(0, len(product_ids), batch_size):\n        i_end = min(i + batch_size, len(product_ids))\n        ids = product_ids[i:i_end]\n        sparse_batch = sparse_vectors[i:i_end]\n        dense_batch = dense_vectors[i:i_end]\n        meta_batch = metadata[i:i_end] if metadata else []\n\n        vectors = []\n        for _id, sparse, dense, meta in zip(ids, sparse_batch, dense_batch, meta_batch):\n            vectors.append({\n                'id': _id,\n                'sparse_values': sparse,\n                'values': dense,\n                'metadata': meta\n            })\n\n        # Pinecone index में vectors को upsert करें।\n        index.upsert(vectors=vectors)\n\nadd_product_data_to_index(product_ids, sparse_vectors, dense_vectors)\n</code></pre>\n\n<p>अब जब हमारा डेटा indexed है, तो हम hybrid search queries कर सकते हैं।</p>\n\n<h3>5. Queries बनाना और Parameters को ट्यून करना</h3>\n\n<img src=\"/assets/images/pinecone_hybrid_query.jpg\" alt=\"Pinecone Hybrid Query\" class=\"post-img\" />\n<span class=\"post-img-caption\">साधारण Pinecone Hybrid Query का उच्च-स्तरीय दृश्य</span>\n\n<p>Hybrid search queries बनाने के लिए, हम एक फंक्शन बनाएंगे जो एक query, शीर्ष परिणामों की संख्या, और dense और sparse vector search scores के बीच weighting को नियंत्रित करने के लिए एक alpha parameter लेता है।</p>\n\n<pre><code class=\"language-python\">def hybrid_scale(dense, sparse, alpha: float):\n    \"\"\"Convex combination का उपयोग करके hybrid vector scaling\n\n    alpha * dense + (1 - alpha) * sparse\n\n    Args:\n        dense: floats का array जो प्रतिनिधित्व करता है\n        sparse: `indices` और `values` का एक dict\n        alpha: 0 और 1 के बीच float जहां 0 == केवल sparse\n               और 1 == केवल dense\n    \"\"\"\n    if alpha &lt; 0 or alpha &gt; 1:\n        raise ValueError(\"Alpha 0 और 1 के बीच होना चाहिए\")\n    # hybrid search vecs बनाने के लिए sparse और dense vectors को scale करें\n    hsparse = {\n        'indices': sparse['indices'],\n        'values':  [v * (1 - alpha) for v in sparse['values']]\n    }\n    hdense = [v * alpha for v in dense]\n    return hdense, hsparse\n\ndef search_products(query, top_k=10, alpha=0.5):\n    # Sparse query vector उत्पन्न करें\n    sparse_query_vector = generate_sparse_vector(query)\n\n    # Dense query vector उत्पन्न करें\n    dense_query_vector = generate_dense_vector(query)\n\n    # Hybrid query vector की गणना करें\n    dense_query_vector, sparse_query_vector = hybrid_scale(dense_query_vector, sparse_query_vector, alpha)\n\n    # Pinecone का उपयोग करके उत्पादों को खोजें\n    results = index.query(\n        vector=dense_query_vector,\n        sparse_vector=sparse_query_vector,\n        top_k=top_k\n    )\n\n    return results\n</code></pre>\n\n<p>फिर हम इस फंक्शन का उपयोग अपने e-commerce dataset में संबंधित उत्पादों को खोजने के लिए कर सकते हैं।</p>\n\n<pre><code class=\"language-python\">query = \"running shoes for women\"\nresults = search_products(query, top_k=5)\n\nfor result in results:\n    print(result['id'], result['metadata']['product_name'], result['score'])\n</code></pre>\n\n<p>Alpha parameter के लिए विभिन्न मूल्यों के साथ प्रयोग करने से आपको अपने विशिष्ट डोमेन के लिए sparse और dense vector search के बीच इष्टतम संतुलन खोजने में मदद मिलेगी।</p>\n\n<h2>निष्कर्ष</h2>\n\n<p>इस ब्लॉग पोस्ट में, हमने Pinecone और domain-specific language models का उपयोग करके e-commerce के लिए एक hybrid search प्रणाली बनाने का तरीका प्रदर्शित किया। Hybrid search हमें पारंपरिक खोज और vector search दोनों की ताकत को संयोजित करने में सक्षम बनाता है, जो विविध डोमेन में खोज प्रदर्शन और अनुकूलनशीलता में सुधार करता है।</p>\n\n<p>इस पोस्ट में प्रदान किए गए चरणों और code snippets का पालन करके, आप अपनी e-commerce वेबसाइट की विशिष्ट आवश्यकताओं के अनुरूप अपनी खुद की hybrid search प्रणाली लागू कर सकते हैं। Pinecone की खोज शुरू करें और आज ही अपने e-commerce खोज अनुभव को बेहतर बनाएं!</p>\n\n<h2>संदर्भ</h2>\n\n<ul>\n<li><a href=\"https://colab.research.google.com/github/pinecone-io/examples/blob/master/search/hybrid-search/ecommerce-search/ecommerce-search.ipynb\">Ecommerce Search using Hybrid Search Techniques in Pinecone (Google Colab Notebook)</a>: Pinecone की hybrid search तकनीकों का उपयोग करके e-commerce खोज के कार्यान्वयन को प्रदर्शित करने वाली एक व्यावहारिक मार्गदर्शिका।</li>\n<li><a href=\"https://docs.pinecone.io/docs/ecommerce-search\">Pinecone Ecommerce Search Documentation</a>: E-commerce खोज प्रणाली बनाने के लिए आधिकारिक Pinecone documentation।</li>\n<li><a href=\"https://colab.research.google.com/github/pinecone-io/examples/blob/master/pinecone/sparse/bm25/bm25-vector-generation.ipynb\">BM25 Vector Generation using Pinecone (Google Colab Notebook)</a>: Pinecone का उपयोग करके BM25 sparse vectors उत्पन्न करने के लिए एक मार्गदर्शिका।</li>\n<li><a href=\"https://github.com/pinecone-io/pinecone-text\">Pinecone Text Repository on GitHub</a>: Pinecone का उपयोग करके टेक्स्ट प्रोसेसिंग और vector generation संसाधनों का एक संग्रह।</li>\n<li><a href=\"https://www.pinecone.io/learn/hybrid-search-intro/\">Introduction to Hybrid Search on Pinecone's Website</a>: Pinecone की क्षमताओं के संदर्भ में hybrid search, इसके लाभ और use cases का एक अवलोकन।</li>\n</ul>",
  "source_hash": "sha256:14601d746f122e4e17ae78f475838ea1679e3865f9f52de9e7fc610d6b5fb139",
  "model": "claude-sonnet-4-5-20250929",
  "generated_at": "2026-01-01T23:57:54.864074+00:00"
}