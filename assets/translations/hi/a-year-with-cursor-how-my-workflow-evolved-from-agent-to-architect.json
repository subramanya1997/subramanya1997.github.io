{
  "title": "Cursor के साथ एक साल: मेरा वर्कफ़्लो कैसे एजेंट से आर्किटेक्ट तक विकसित हुआ",
  "excerpt": "Cursor के साथ मेरी यात्रा टूल की परिपक्वता को दर्शाती है: एक साधारण एजेंट से एक परिष्कृत आर्किटेक्चरल पार्टनर तक। यह पोस्ट विस्तार से बताती है कि @ mentions, MCP, Plan Mode, और कस्टम कमांड्स के माध्यम से मेरा वर्कफ़्लो कैसे विकसित हुआ।",
  "content_html": "<p>Cursor को अपना प्राथमिक IDE बनाए हुए एक साल से अधिक हो गया है, और इसका मेरे काम पर पड़े प्रभाव को बढ़ा-चढ़ाकर बताना मुश्किल है। Dylog में conversational AI प्लेटफ़ॉर्म बनाने वाले एक machine learning engineer के रूप में और अपने व्यक्तिगत प्रोजेक्ट्स पर agentic infrastructure के साथ प्रयोग करते हुए, मैंने AI-native development के विकास को जिया है। Cursor के साथ मेरी यात्रा टूल की परिपक्वता को दर्शाती है: एक साधारण एजेंट से एक परिष्कृत आर्किटेक्चरल पार्टनर तक।</p>\n\n<p>यह पोस्ट उस यात्रा पर एक चिंतन है, जो विस्तार से बताती है कि मेरा वर्कफ़्लो कैसे विकसित हुआ और मैं तेज़ी से, स्मार्ट तरीके से, और अधिक स्पष्टता के साथ निर्माण करने के लिए Plan Mode, कस्टम कमांड्स, और context engineering के शक्तिशाली संयोजन पर कैसे निर्भर हो गया हूं।</p>\n\n<h2>चरण 1: एजेंट ने पकड़ी कमान</h2>\n\n<p>जब मैंने पहली बार शुरुआत की, तो मेरा उपयोग सरल था। मैं Cursor को एक सुपरचार्ज्ड autocomplete की तरह मानता था। मैं एक comment लिखता, <code>Cmd+K</code> दबाता, और एजेंट को कोड जेनरेट करने देता। यह जादुई था, लेकिन यह एक black box भी था। मैं एक यात्री था, और एजेंट ड्राइव कर रहा था।</p>\n\n<p>फिर आए <strong>@ mentions</strong>। यह एजेंट को वास्तविक context देने का मेरा पहला अनुभव था। उम्मीद करने के बजाय कि वह मेरे codebase को समझे, मैं स्पष्ट रूप से बता सकता था कि क्या देखना है:</p>\n\n<ul>\n<li><code>@file</code> किसी विशिष्ट फ़ाइल को संदर्भित करने के लिए</li>\n<li><code>@folder</code> पूरी directory को शामिल करने के लिए</li>\n<li><code>@codebase</code> पूरे प्रोजेक्ट में खोज करने के लिए</li>\n<li><code>@web</code> बाहरी documentation लाने के लिए</li>\n<li><code>@docs</code> libraries के लिए official docs को संदर्भित करने के लिए</li>\n</ul>\n\n<p>यह एक बड़ी छलांग थी। अचानक, एजेंट अनुमान नहीं लगा रहा था; वह उसी context के साथ काम कर रहा था जो मेरे पास था। मैं कह सकता था \"इस function को <code>@file:utils/helpers.ts</code> में pattern से मिलाने के लिए refactor करें\" और वह वास्तव में समझ जाता।</p>\n\n<p><img src=\"/assets/images/cursor-at-mentions.png\" alt=\"Cursor @ mention context\" class=\"post-img\" />\n<span class=\"post-img-caption\">Cursor में @ mention dropdown, जो @file, @folder, @codebase, @web, और @docs जैसे context options दिखाता है जो स्पष्ट context control की अनुमति देते हैं</span></p>\n\n<p>लेकिन बेहतर context के साथ भी, मैं अक्सर खुद को generating, debugging, और regenerating के loop में पाता था। एजेंट में बड़े कार्यों के लिए architectural vision की कमी थी।</p>\n\n<h2>चरण 2: MCP ने सब कुछ बदल दिया</h2>\n\n<p><strong>Model Context Protocol (MCP)</strong> की शुरुआत वह समय था जब चीजें गंभीर हो गईं। MCP ने मुझे Cursor को बाहरी tools और data sources से जोड़ने की अनुमति दी, जिससे एजेंट एक code generator से मेरे पूरे वर्कफ़्लो तक पहुंच वाले एक सच्चे assistant में बदल गया।</p>\n\n<p>मैंने MCPs को integrate करना शुरू किया:</p>\n\n<ul>\n<li><strong>GitHub</strong> issues और PRs को सीधे context में लाने के लिए</li>\n<li><strong>Linear</strong> task management integration के लिए</li>\n<li><strong>Slack</strong> team communication context के लिए</li>\n<li><strong>Custom MCPs</strong> internal APIs और databases के लिए</li>\n</ul>\n\n<p>MCP के साथ, मैं कह सकता था \"Linear issue #234 में वर्णित feature को implement करें\" और एजेंट issue fetch करता, requirements समझता, और निर्माण शुरू करता। यह अब केवल code के बारे में नहीं था; यह मेरे पूरे development ecosystem में बिंदुओं को जोड़ने के बारे में था।</p>\n\n<p><img src=\"/assets/images/cursor-mcp-integrations.png\" alt=\"MCP integrations in Cursor\" class=\"post-img\" />\n<span class=\"post-img-caption\">MCP configuration panel जो GitHub, Linear, Slack, और custom servers जैसे connected integrations दिखाता है जो development ecosystem में Cursor की क्षमताओं को विस्तारित करते हैं</span></p>\n\n<h2>चरण 3: Planner का उदय</h2>\n\n<p><strong>Plan Mode</strong> की शुरुआत अगला game-changer था। यह पहली बार था जब मुझे लगा कि मैं AI के साथ सहयोग कर रहा हूं, न कि केवल उसे सौंप रहा हूं। Ray Fernando जैसे developers के workflows से प्रेरित होकर, मैंने दो-चरणीय प्रक्रिया का उपयोग करना शुरू किया:</p>\n\n<ol>\n<li><p><strong>Opus के साथ Plan करें:</strong> मैं Claude Opus जैसे शक्तिशाली model का उपयोग एक विस्तृत, step-by-step implementation plan बनाने के लिए करता। मैं इसे high-level goal देता, और यह इसे concrete tasks की एक श्रृंखला में तोड़ देता, file names, function signatures, और logic के साथ पूर्ण।</p></li>\n<li><p><strong>Sonnet/GPT के साथ Execute करें:</strong> फिर मैं उस plan को Sonnet या GPT-5.2 जैसे तेज़, सस्ते model को सौंपता प्रत्येक step को execute करने के लिए। सस्ते model को एक शानदार architect होने की ज़रूरत नहीं थी; उसे बस एक मेहनती builder होने की ज़रूरत थी।</p></li>\n</ol>\n\n<p>यह वर्कफ़्लो एक बड़ा सुधार था। इसने \"क्या\" को \"कैसे\" से अलग किया, और इसने मुझे एक reviewable artifact—plan—दिया जिसे मैं कोई भी code लिखे जाने से पहले edit और approve कर सकता था। इसने tokens पर भी बहुत पैसे बचाए।</p>\n\n<p><img src=\"/assets/images/cursor-plan-mode.png\" alt=\"Cursor Plan Mode workflow\" class=\"post-img\" />\n<span class=\"post-img-caption\">एक split view जो बाईं ओर <code>.cursor/plans/</code> file में विस्तृत implementation plan दिखाता है, और दाईं ओर corresponding generated code, जो architecture को execution से अलग करने का प्रदर्शन करता है</span></p>\n\n<h2>चरण 4: Architect का उदय (Commands + Planning)</h2>\n\n<p>यहीं मैं आज रहता हूं। जबकि Plan Mode अभी भी मेरे वर्कफ़्लो के केंद्र में है, मैंने प्रक्रिया को fine-tune करने और अपने architectural principles को सीधे IDE में बेक करने के लिए <strong>custom commands</strong> और <strong>rules</strong> का एक सेट जोड़ा है।</p>\n\n<h3>मेरा वर्तमान सेटअप</h3>\n\n<p><strong>Rules (<code>.cursorrules</code>):</strong> मेरे पास rules का एक सेट है जो मेरे coding standards, preferred patterns, और architectural constraints को परिभाषित करता है। एजेंट हर task से पहले इन्हें पढ़ता है, जो codebase में consistency सुनिश्चित करता है।</p>\n\n<p><strong>Custom Commands:</strong> मैंने commands बनाए हैं जो मेरे सबसे सामान्य workflows को wrap करते हैं:</p>\n\n<ul>\n<li><code>/plan</code> - Opus का उपयोग करके विस्तृत implementation plan बनाता है</li>\n<li><code>/refactor</code> - एक file लेता है और instructions के आधार पर इसे refactor करता है</li>\n<li><code>/test</code> - दिए गए function के लिए test suite बनाता है</li>\n<li><code>/review</code> - मेरे rules के खिलाफ code की समीक्षा करता है और सुधार सुझाता है</li>\n</ul>\n\n<p><strong>Queued Messages:</strong> मैं <code>Ctrl+Enter</code> का उपयोग एजेंट के काम करते समय follow-up instructions को queue करने के लिए करता हूं। यह मुझे आगे सोचने और वर्तमान task को बाधित किए बिना momentum बनाए रखने देता है।</p>\n\n<p><img src=\"/assets/images/cursor-custom-commands.png\" alt=\"Cursor custom commands and rules\" class=\"post-img\" />\n<span class=\"post-img-caption\">Cursor command palette जो /plan, /refactor, /test, और /review जैसे custom commands दिखाता है, एक <code>.cursorrules</code> file के साथ जो coding standards और architectural constraints को परिभाषित करती है</span></p>\n\n<h2>एक नज़र में विकास</h2>\n\n<table>\n<thead>\n<tr>\n<th>चरण</th>\n<th>मुख्य विशेषता</th>\n<th>क्या बदला</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>Agent Mode + @ Mentions</td>\n<td>Context स्पष्ट हो गया, अनुमानित नहीं</td>\n</tr>\n<tr>\n<td>2</td>\n<td>MCP Integration</td>\n<td>बाहरी tools और data सुलभ हो गए</td>\n</tr>\n<tr>\n<td>3</td>\n<td>Plan Mode</td>\n<td>Architecture execution से अलग हो गई</td>\n</tr>\n<tr>\n<td>4</td>\n<td>Commands + Rules</td>\n<td>Workflows दोहराने योग्य और व्यक्तिगत बन गए</td>\n</tr>\n</tbody>\n</table>\n\n<h2>यह क्यों मायने रखता है</h2>\n\n<p>एजेंट से architect तक का यह विकास केवल एक व्यक्तिगत productivity hack से अधिक है। यह software development के भविष्य की एक झलक है। हम एक ऐसी दुनिया से आगे बढ़ रहे हैं जहां हम code लिखते हैं एक ऐसी दुनिया की ओर जहां हम <strong>systems का वर्णन करते हैं</strong>। हमारा काम architect होना है, blueprint को परिभाषित करना है, और एजेंटों को निर्माण करने देना है।</p>\n\n<p>Cursor, मेरे द्वारा उपयोग किए गए किसी भी अन्य tool से अधिक, इस बदलाव को समझता है। यह केवल code generate करने के बारे में नहीं है; यह complexity को manage करने, context बनाए रखने, और developers को उस पैमाने पर निर्माण करने का leverage देने के बारे में है जो पहले अकल्पनीय था।</p>\n\n<p>यदि आप अभी भी AI का उपयोग एक साधारण code generator के रूप में कर रहे हैं, तो मैं आपको @ mentions, MCP, Plan Mode, और custom commands का पता लगाने के लिए प्रोत्साहित करता हूं। यह एक यात्रा है जो आपको एक developer से जो AI का उपयोग करता है एक architect में बदल देगी जो इसे निर्देशित करता है।</p>",
  "source_hash": "sha256:662561f10cc6e2a91c66508ff149182da2e11a387f342090ce2e43b96d291d1b",
  "model": "claude-sonnet-4-5-20250929",
  "generated_at": "2026-01-05T01:55:09.301765+00:00"
}