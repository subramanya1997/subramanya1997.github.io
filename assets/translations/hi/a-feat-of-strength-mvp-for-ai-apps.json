{
  "title": "AI Apps के लिए एक फीट ऑफ स्ट्रेंथ MVP",
  "excerpt": "AI अनुप्रयोगों में Minimum Viable Product (MVP) की अवधारणा की खोज, जो उपयोगकर्ता की जरूरतों को समझकर और प्रभावी ढंग से संबोधित करके मूल्य प्रदान करने पर केंद्रित है।",
  "content_html": "<p>एक minimum viable product (MVP) किसी उत्पाद का ऐसा संस्करण होता है जिसमें केवल इतनी सुविधाएँ होती हैं कि शुरुआती ग्राहक इसे उपयोग कर सकें, जो फिर भविष्य के उत्पाद विकास के लिए फीडबैक प्रदान कर सकते हैं।</p>\n\n<p>आज मैं इस पर ध्यान केंद्रित करना चाहता हूँ कि AI अनुप्रयोगों को शिप करने के लिए यह कैसा दिखता है। ऐसा करने के लिए, हमें केवल 4 चीजों को समझने की जरूरत है।</p>\n<ul>\n<li>80% का वास्तव में क्या मतलब है?</li>\n<li>हम किन segments को अच्छी तरह से serve कर सकते हैं?</li>\n<li>क्या हम double down कर सकते हैं?</li>\n<li>क्या हम उपयोगकर्ता को उन segments के बारे में शिक्षित कर सकते हैं जिन्हें हम अच्छी तरह से serve नहीं करते?</li>\n</ul>\n\n<p>Pareto सिद्धांत, जिसे 80/20 नियम के रूप में भी जाना जाता है, अभी भी लागू होता है लेकिन एक अलग तरीके से जो आप सोच सकते हैं।</p>\n\n<h3>MVP क्या है?</h3>\n<p>इस अवधारणा को समझने में मदद के लिए मैं अक्सर एक उपमा का उपयोग करता हूँ: आपको बिंदु A से बिंदु B तक जाने में मदद करने के लिए कुछ चाहिए। शायद दृष्टि एक कार रखने की है। हालांकि, MVP बिना पहियों या इंजन के chassis नहीं है। इसके बजाय, यह एक skateboard की तरह दिख सकता है। आप ship करेंगे और महसूस करेंगे कि उत्पाद को brakes या steering की जरूरत है। तो फिर आप एक scooter ship करते हैं। बाद में, आप पता लगाते हैं कि scooter को अधिक leverage की जरूरत है, इसलिए आप बड़े पहिये जोड़ते हैं और एक bicycle के साथ समाप्त होते हैं। एक इंसान के रूप में आप जो बल लगा सकते हैं उससे सीमित होकर, आप motors के बारे में सोचना शुरू करते हैं और mopeds, e-bikes, और motorcycles में branch out कर सकते हैं। फिर एक दिन, car ship करें।</p>\n\n<h3>80/20 नियम पर विचार करें</h3>\n<p>जब किसी चीज़ के 80% पूर्ण होने या 80% तैयार होने के बारे में बात करते हैं, तो यह आमतौर पर machine-learning के अर्थ में होता है। इस संदर्भ में, प्रत्येक component deterministic है, जिसका अर्थ है कि 80% का अनुवाद 10 में से 8 सुविधाओं के पूर्ण होने में होता है। एक बार जब शेष 2 सुविधाएँ तैयार हो जाती हैं, तो हम उत्पाद को ship कर सकते हैं। हालांकि, यदि हम 80/20 नियम का पालन करना चाहते हैं, तो हम 80% सुविधाओं के साथ उत्पाद को ship करने में सक्षम हो सकते हैं और फिर शेष 20% को बाद में जोड़ सकते हैं, जैसे कि बिना radio या air conditioning के एक car। हालांकि, 80% का अर्थ काफी भिन्न हो सकता है, और यह परिभाषा AI-powered अनुप्रयोग पर लागू नहीं हो सकती है।</p>\n\n<p><strong>Summary Statistics के साथ समस्या</strong><br>\n<img src=\"/assets/images/anscombes_quartet.png\" alt=\"Anscombe's quartet\" class=\"post-img\"><br>\nउपरोक्त छवि Anscombe's quartet का एक उदाहरण है। यह चार datasets का एक सेट है जिनके लगभग समान सरल वर्णनात्मक आँकड़े हैं फिर भी बहुत अलग distributions और appearances हैं। यह एक क्लासिक व्याख्या है कि summary statistics भ्रामक क्यों हो सकते हैं।</p>\n\n<p>निम्नलिखित उदाहरण पर विचार करें:</p>\n\n<table>\n    <thead>\n        <tr>\n            <th>Query_id</th>\n            <th>score</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <td>1</td>\n            <td>0.9</td>\n        </tr>\n        <tr>\n            <td>2</td>\n            <td>0.8</td>\n        </tr>\n        <tr>\n            <td>3</td>\n            <td>0.9</td>\n        </tr>\n        <tr>\n            <td>4</td>\n            <td>0.9</td>\n        </tr>\n        <tr>\n            <td>5</td>\n            <td>0.0</td>\n        </tr>\n        <tr>\n            <td>6</td>\n            <td>0.0</td>\n        </tr>\n    </tbody>\n</table>\n\n<p>औसत score 0.58 है। हालांकि, यदि हम segments के भीतर queries का विश्लेषण करते हैं, तो हम पा सकते हैं कि हम अधिकांश queries को असाधारण रूप से अच्छी तरह से serve कर रहे हैं!</p>\n\n<blockquote>\n<p><strong>स्वीकार करना कि आप किसमें बुरे हैं</strong></p>\n<p>इस बारे में ईमानदार होना कि आप किसमें बुरे हैं, अपने उपयोगकर्ताओं के साथ विश्वास बनाने का एक शानदार तरीका है। यदि आप सटीक रूप से पहचान सकते हैं कि कब कुछ खराब प्रदर्शन करेगा और आत्मविश्वास से इसे reject कर सकते हैं, तो आप एक शानदार उत्पाद ship करने के लिए तैयार हो सकते हैं जबकि अपने उपयोगकर्ताओं को अपने अनुप्रयोग की सीमाओं के बारे में शिक्षित कर सकते हैं।</p>\n</blockquote>\n\n<p>अपने सिस्टम की सीमाओं को समझना और summary statistics से परे अपने सिस्टम की विशेषताओं को आत्मविश्वास से समझने में सक्षम होना बहुत महत्वपूर्ण है। ऐसा इसलिए है क्योंकि सभी सिस्टम समान नहीं बनाए गए हैं। एक probabilistic सिस्टम का व्यवहार पिछले उदाहरण से बहुत अलग हो सकता है। निम्नलिखित dataset पर विचार करें:</p>\n\n<table>\n    <thead>\n        <tr>\n            <th>Query_id</th>\n            <th>Score</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <td>1</td>\n            <td>.59</td>\n        </tr>\n        <tr>\n            <td>2</td>\n            <td>.58</td>\n        </tr>\n        <tr>\n            <td>3</td>\n            <td>.59</td>\n        </tr>\n        <tr>\n            <td>4</td>\n            <td>.57</td>\n        </tr>\n    </tbody>\n</table>\n\n<p>इस तरह के एक सिस्टम में भी 0.58 का औसत score है, लेकिन requests के किसी भी subset को reject करना उतना आसान नहीं है...</p>\n\n<h3>ना कहना सीखना</h3>\n<p>एक RAG अनुप्रयोग पर विचार करें जहाँ queries का एक बड़ा हिस्सा timeline queries के बारे में है। यदि हमारे search engines इस समय की बाधा का समर्थन नहीं करते हैं, तो हम संभवतः अच्छा प्रदर्शन करने में असमर्थ होंगे।</p>\n\n<table>\n    <thead>\n        <tr>\n            <th>Query_id</th>\n            <th>Score</th>\n            <th>Query Type</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <td>1</td>\n            <td>0.9</td>\n            <td>text search</td>\n        </tr>\n        <tr>\n            <td>2</td>\n            <td>0.8</td>\n            <td>text search</td>\n        </tr>\n        <tr>\n            <td>3</td>\n            <td>0.9</td>\n            <td>news search</td>\n        </tr>\n        <tr>\n            <td>4</td>\n            <td>0.9</td>\n            <td>news search</td>\n        </tr>\n        <tr>\n            <td>5</td>\n            <td>0.0</td>\n            <td>timeline</td>\n        </tr>\n        <tr>\n            <td>6</td>\n            <td>0.0</td>\n            <td>timeline</td>\n        </tr>\n    </tbody>\n</table>\n\n<p>यदि हम ship करने की जल्दी में हैं, तो हम बस एक classification model बना सकते हैं जो पता लगाता है कि ये प्रश्न timeline प्रश्न हैं या नहीं और एक चेतावनी फेंक सकते हैं। लगातार algorithm को बेहतर करने की कोशिश करने के बजाय, हम उपयोगकर्ता को शिक्षित कर सकते हैं और उन्हें उत्पाद को डिजाइन करने के तरीके को बदलकर शिक्षित कर सकते हैं।</p>\n\n<blockquote>\n<p><strong>Segments का पता लगाना</strong></p>\n<p>इन segments का पता लगाना विभिन्न तरीकों से पूरा किया जा सकता है। हम एक classifier का निर्माण कर सकते हैं या उन्हें categorize करने के लिए एक language model का उपयोग कर सकते हैं। इसके अतिरिक्त, हम सामान्य समूहों की पहचान करने के लिए embeddings के साथ clustering algorithms का उपयोग कर सकते हैं और संभावित रूप से प्रत्येक समूह के भीतर mean scores का विश्लेषण कर सकते हैं। एकमात्र उद्देश्य ऐसे segments की पहचान करना है जो विशिष्ट subgroups के भीतर गतिविधियों की हमारी समझ को बढ़ा सकें।</p>\n</blockquote>\n\n<p>सबसे बुरी चीजों में से एक जो आप कर सकते हैं वह है महीनों एक ऐसी सुविधा का निर्माण करना जो केवल आपकी उत्पादकता को थोड़ा बढ़ाती है जबकि आपके उपयोगकर्ता आधार के कुछ अधिक महत्वपूर्ण segment की अनदेखी करती है।</p>\n\n<p>अपने अनुप्रयोग को फिर से डिजाइन करके और इसकी सीमाओं को पहचानकर, हम संभावित रूप से कुछ शर्तों के तहत प्रदर्शन में सुधार कर सकते हैं उन कार्यों के प्रकारों की पहचान करके जिन्हें हम decline कर सकते हैं। यदि हम इस segment data को किसी प्रकार की In-System Observability में डालने में सक्षम हैं, तो हम सुरक्षित रूप से monitor कर सकते हैं कि प्रश्नों का कितना हिस्सा अस्वीकार किया जा रहा है और coverage को अधिकतम करने के लिए अपने काम को प्राथमिकता दे सकते हैं।</p>\n\n<h3>पता लगाएं कि आप वास्तव में क्या करने की कोशिश कर रहे हैं इससे पहले कि आप इसे करें</h3>\n<p>मैंने startups के साथ काम करते हुए देखा है कि खतरनाक चीजों में से एक यह है कि हम अक्सर सोचते हैं कि AI बिल्कुल काम करता है... परिणामस्वरूप, हम एक बड़े सामान्य अनुप्रयोग को serve करने में सक्षम होना चाहते हैं बिना इस बारे में अधिक सोचे कि हम वास्तव में क्या हासिल करना चाहते हैं।</p>\n\n<p>मेरी राय में, इनमें से अधिकांश कंपनियों को एक या दो महत्वपूर्ण क्षेत्रों पर ध्यान केंद्रित करने की कोशिश करनी चाहिए और target करने के लिए एक अच्छा niche की पहचान करनी चाहिए। यदि आपका app एक या दो कार्यों में अच्छा है, तो कोई रास्ता नहीं है कि आप अपने अनुप्रयोग का परीक्षण करने और जल्दी से feedback प्राप्त करने के लिए सौ या दो सौ उपयोगकर्ताओं को नहीं पा सकें। जबकि, यदि आपका अनुप्रयोग कुछ भी अच्छा नहीं है, तो यादगार होना और कुछ ऐसा प्रदान करना मुश्किल होगा जिसका बार-बार उपयोग हो। आपको कुछ virality मिल सकती है, लेकिन बहुत जल्दी, आप अपने उपयोगकर्ताओं का विश्वास खो देंगे और खुद को ऐसी स्थिति में पाएंगे जहाँ आप churn को कम करने की कोशिश कर रहे हैं।</p>\n\n<p>जब हम front-loaded होते हैं, तो predictions करने के लिए GPT-4 का उपयोग करने की क्षमता, और feedback का समय बहुत महत्वपूर्ण है। यदि हम जल्दी से feedback प्राप्त कर सकते हैं, तो हम जल्दी से iterate कर सकते हैं। यदि हम जल्दी से iterate कर सकते हैं, तो हम एक बेहतर उत्पाद बना सकते हैं।</p>\n\n<h3>अंतिम विचार</h3>\n<p>एक AI अनुप्रयोग के लिए MVP 80% सुविधाओं के साथ एक उत्पाद ship करने जितना सरल नहीं है। इसके बजाय, इसके लिए आपके उपयोगकर्ताओं के उन segments की गहरी समझ की आवश्यकता होती है जिन्हें आप अच्छी तरह से serve कर सकते हैं और अपने उपयोगकर्ताओं को उन segments के बारे में शिक्षित करने की क्षमता जिन्हें आप अच्छी तरह से serve नहीं करते हैं। अपने सिस्टम की सीमाओं को समझकर और niche down करके, आप एक ऐसा उत्पाद बना सकते हैं जो यादगार हो और कुछ ऐसा प्रदान करे जिसका बार-बार उपयोग हो। यह आपको जल्दी से feedback प्राप्त करने और जल्दी से iterate करने की अनुमति देगा, अंततः एक बेहतर उत्पाद की ओर ले जाएगा, अपनी feats of strength की पहचान करके।</p>",
  "source_hash": "sha256:bd2871ce1f7be1eb8b82f87af3b6a125ec8b75299b758ba02e9c9ff25c11df30",
  "model": "claude-sonnet-4-5-20250929",
  "generated_at": "2026-01-02T00:15:36.392973+00:00"
}