{
  "title": "Un an avec Cursor : Comment mon flux de travail a évolué d'agent à architecte",
  "excerpt": "Mon parcours avec Cursor reflète la maturation de l'outil lui-même : d'un simple agent à un partenaire architectural sophistiqué. Cet article détaille comment mon flux de travail a évolué à travers les mentions @, MCP, le Mode Plan et les commandes personnalisées.",
  "content_html": "<p>Cela fait plus d'un an que j'ai fait de Cursor mon IDE principal, et il est difficile de surestimer l'impact qu'il a eu sur mon travail. En tant qu'ingénieur en apprentissage automatique construisant des plateformes d'IA conversationnelle chez Dylog et expérimentant avec des infrastructures agentiques sur mes projets personnels, j'ai vécu l'évolution du développement natif IA. Mon parcours avec Cursor reflète la maturation de l'outil lui-même : d'un simple agent à un partenaire architectural sophistiqué.</p>\n\n<p>Cet article est une réflexion sur ce parcours, détaillant comment mon flux de travail a évolué et comment j'en suis venu à compter sur une combinaison puissante du Mode Plan, de commandes personnalisées et d'ingénierie de contexte pour construire plus rapidement, plus intelligemment et avec plus de clarté.</p>\n\n<h2>Phase 1 : L'agent prend le volant</h2>\n\n<p>Quand j'ai commencé, mon utilisation était simple. Je traitais Cursor comme une autocomplétion surpuissante. J'écrivais un commentaire, j'appuyais sur <code>Cmd+K</code>, et je laissais l'agent générer le code. C'était magique, mais c'était aussi une boîte noire. J'étais un passager, et l'agent conduisait.</p>\n\n<p>Puis sont venues les <strong>mentions @</strong>. C'était mon premier avant-goût de donner un vrai contexte à l'agent. Au lieu d'espérer qu'il comprenne ma base de code, je pouvais explicitement lui dire quoi regarder :</p>\n\n<ul>\n<li><code>@file</code> pour référencer un fichier spécifique</li>\n<li><code>@folder</code> pour inclure un répertoire entier</li>\n<li><code>@codebase</code> pour le laisser chercher dans tout le projet</li>\n<li><code>@web</code> pour récupérer de la documentation externe</li>\n<li><code>@docs</code> pour référencer la documentation officielle des bibliothèques</li>\n</ul>\n\n<p>C'était un bond énorme. Soudain, l'agent ne devinait plus ; il travaillait avec le même contexte que moi. Je pouvais dire \"refactorise cette fonction pour correspondre au pattern dans <code>@file:utils/helpers.ts</code>\" et il comprendrait réellement.</p>\n\n<p><img src=\"/assets/images/cursor-at-mentions.png\" alt=\"Contexte des mentions @ de Cursor\" class=\"post-img\" width=\"1639\" height=\"935\" />\n<span class=\"post-img-caption\">Le menu déroulant des mentions @ dans Cursor, montrant les options de contexte comme @file, @folder, @codebase, @web et @docs qui permettent un contrôle explicite du contexte</span></p>\n\n<p>Mais même avec un meilleur contexte, je me retrouvais souvent dans une boucle de génération, débogage et régénération. L'agent manquait de vision architecturale pour les tâches plus importantes.</p>\n\n<h2>Phase 2 : MCP change tout</h2>\n\n<p>L'introduction du <strong>Model Context Protocol (MCP)</strong> a marqué le moment où les choses sont devenues sérieuses. MCP m'a permis de connecter Cursor à des outils et sources de données externes, transformant l'agent d'un générateur de code en un véritable assistant avec accès à l'ensemble de mon flux de travail.</p>\n\n<p>J'ai commencé à intégrer des MCP pour :</p>\n\n<ul>\n<li><strong>GitHub</strong> pour récupérer les issues et PR directement dans le contexte</li>\n<li><strong>Linear</strong> pour l'intégration de la gestion des tâches</li>\n<li><strong>Slack</strong> pour le contexte de communication d'équipe</li>\n<li><strong>MCP personnalisés</strong> pour les API internes et bases de données</li>\n</ul>\n\n<p>Avec MCP, je pouvais dire \"implémente la fonctionnalité décrite dans l'issue Linear #234\" et l'agent récupérait l'issue, comprenait les exigences et commençait à construire. Ce n'était plus seulement une question de code ; c'était une question de connecter les points à travers tout mon écosystème de développement.</p>\n\n<p><img src=\"/assets/images/cursor-mcp-integrations.png\" alt=\"Intégrations MCP dans Cursor\" class=\"post-img\" width=\"1639\" height=\"935\" />\n<span class=\"post-img-caption\">Panneau de configuration MCP montrant les intégrations connectées comme GitHub, Linear, Slack et des serveurs personnalisés qui étendent les capacités de Cursor à travers l'écosystème de développement</span></p>\n\n<h2>Phase 3 : L'émergence du planificateur</h2>\n\n<p>L'introduction du <strong>Mode Plan</strong> a été le prochain changement majeur. C'était la première fois que je sentais collaborer avec l'IA, pas seulement lui déléguer. Inspiré par les flux de travail de développeurs comme Ray Fernando, j'ai commencé à utiliser un processus en deux étapes :</p>\n\n<ol>\n<li><p><strong>Planifier avec Opus :</strong> J'utilisais un modèle puissant comme Claude Opus pour générer un plan d'implémentation détaillé, étape par étape. Je lui donnais l'objectif de haut niveau, et il le décomposait en une série de tâches concrètes, complètes avec noms de fichiers, signatures de fonctions et logique.</p></li>\n\n<li><p><strong>Exécuter avec Sonnet/GPT :</strong> Je transmettais ensuite ce plan à un modèle plus rapide et moins cher comme Sonnet ou GPT-5.2 pour exécuter chaque étape. Le modèle moins cher n'avait pas besoin d'être un architecte brillant ; il devait juste être un constructeur diligent.</p></li>\n</ol>\n\n<p>Ce flux de travail était une amélioration massive. Il séparait le \"quoi\" du \"comment\", et il me donnait un artefact révisable—le plan—que je pouvais éditer et approuver avant qu'aucun code ne soit écrit. Cela économisait aussi énormément d'argent en tokens.</p>\n\n<p><img src=\"/assets/images/cursor-plan-mode.png\" alt=\"Flux de travail du Mode Plan de Cursor\" class=\"post-img\" width=\"1639\" height=\"935\" />\n<span class=\"post-img-caption\">Une vue divisée montrant un plan d'implémentation détaillé dans un fichier <code>.cursor/plans/</code> à gauche, et le code généré correspondant à droite, démontrant la séparation de l'architecture de l'exécution</span></p>\n\n<h2>Phase 4 : L'architecte émerge (Commandes + Planification)</h2>\n\n<p>C'est là où je vis aujourd'hui. Bien que le Mode Plan soit toujours central dans mon flux de travail, j'ai ajouté un ensemble de <strong>commandes personnalisées</strong> et de <strong>règles</strong> pour affiner le processus et intégrer mes principes architecturaux directement dans l'IDE.</p>\n\n<h3>Ma configuration actuelle</h3>\n\n<p><strong>Règles (<code>.cursorrules</code>) :</strong> J'ai un ensemble de règles qui définissent mes standards de codage, patterns préférés et contraintes architecturales. L'agent les lit avant chaque tâche, assurant la cohérence à travers la base de code.</p>\n\n<p><strong>Commandes personnalisées :</strong> J'ai construit des commandes qui encapsulent mes flux de travail les plus courants :</p>\n\n<ul>\n<li><code>/plan</code> - Génère un plan d'implémentation détaillé en utilisant Opus</li>\n<li><code>/refactor</code> - Prend un fichier et le refactorise selon les instructions</li>\n<li><code>/test</code> - Génère une suite de tests pour une fonction donnée</li>\n<li><code>/review</code> - Révise le code par rapport à mes règles et suggère des améliorations</li>\n</ul>\n\n<p><strong>Messages en file d'attente :</strong> J'utilise <code>Ctrl+Enter</code> pour mettre en file d'attente des instructions de suivi pendant que l'agent travaille. Cela me permet de penser à l'avance et de maintenir l'élan sans interrompre la tâche en cours.</p>\n\n<p><img src=\"/assets/images/cursor-custom-commands.png\" alt=\"Commandes personnalisées et règles de Cursor\" class=\"post-img\" width=\"1639\" height=\"935\" />\n<span class=\"post-img-caption\">La palette de commandes de Cursor montrant des commandes personnalisées comme /plan, /refactor, /test et /review, aux côtés d'un fichier <code>.cursorrules</code> qui définit les standards de codage et les contraintes architecturales</span></p>\n\n<h2>L'évolution en un coup d'œil</h2>\n\n<table>\n<thead>\n<tr>\n<th>Phase</th>\n<th>Fonctionnalité clé</th>\n<th>Ce qui a changé</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>Mode Agent + Mentions @</td>\n<td>Le contexte est devenu explicite, non deviné</td>\n</tr>\n<tr>\n<td>2</td>\n<td>Intégration MCP</td>\n<td>Les outils et données externes sont devenus accessibles</td>\n</tr>\n<tr>\n<td>3</td>\n<td>Mode Plan</td>\n<td>L'architecture séparée de l'exécution</td>\n</tr>\n<tr>\n<td>4</td>\n<td>Commandes + Règles</td>\n<td>Les flux de travail sont devenus répétables et personnalisés</td>\n</tr>\n</tbody>\n</table>\n\n<h2>Pourquoi c'est important</h2>\n\n<p>Cette évolution d'agent à architecte est plus qu'un simple hack de productivité personnelle. C'est un aperçu de l'avenir du développement logiciel. Nous passons d'un monde où nous écrivons du code à un monde où nous <strong>décrivons des systèmes</strong>. Notre travail est d'être l'architecte, de définir le plan, et de laisser les agents faire la construction.</p>\n\n<p>Cursor, plus que tout autre outil que j'ai utilisé, comprend ce changement. Il ne s'agit pas seulement de générer du code ; il s'agit de gérer la complexité, de maintenir le contexte et de donner aux développeurs le levier pour construire à une échelle qui était auparavant inimaginable.</p>\n\n<p>Si vous utilisez encore l'IA comme un simple générateur de code, je vous encourage à explorer les mentions @, MCP, le Mode Plan et les commandes personnalisées. C'est un voyage qui vous transformera d'un développeur qui utilise l'IA en un architecte qui la dirige.</p>",
  "source_hash": "sha256:c11c23550cdc336e503f564506c299fa36379c99fe4b8cff420d4a83f91c4e64",
  "model": "claude-sonnet-4-5-20250929",
  "generated_at": "2026-01-15T20:25:17.399648+00:00"
}