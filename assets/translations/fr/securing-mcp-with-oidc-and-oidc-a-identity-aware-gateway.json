{
  "title": "Sécuriser MCP avec OIDC et OIDC-A : Passerelles API conscientes de l'identité au-delà des « simples appels API glorifiés »",
  "excerpt": "Intégration d'OpenID Connect (OIDC) et de la nouvelle extension agent OIDC-A avec une passerelle API consciente de l'identité pour authentifier de manière sécurisée les utilisateurs, les agents LLM et les outils MCP—allant bien au-delà du simple proxy d'API.",
  "content_html": "<p>Les agents IA passent rapidement des démos de recherche aux applications d'entreprise réelles, connectant les grands modèles de langage (LLM) aux données et services de l'entreprise. Une approche courante consiste à utiliser des outils ou des plugins pour permettre à un LLM de récupérer du contexte ou d'effectuer des actions – mais certains les considèrent comme de simples « appels API glorifiés ». En réalité, l'intégration sécurisée de l'IA avec les systèmes métier est bien plus complexe. C'est là qu'intervient le <strong>Model Context Protocol (MCP)</strong>, et pourquoi une <strong>architecture proxy robuste avec identité OpenID Connect (OIDC)</strong> est cruciale pour les déploiements à l'échelle de l'entreprise.</p>\n\n<pre><code class=\"language-mermaid\">graph TB\n    User[Utilisateur] --&gt; |interagit avec| AIAgent[Agent IA]\n    AIAgent --&gt; |requêtes MCP| Proxy[Passerelle API/Proxy]\n    Proxy --&gt; |authentifie via| OIDC[Fournisseur d'identité/OIDC]\n    Proxy --&gt; |route vers| Tools[Outils/Serveurs MCP]\n    Tools --&gt; |accède à| Backend[Systèmes Backend]\n    \n    subgraph \"Périmètre de sécurité\"\n        Proxy\n        OIDC\n    end\n    \n    classDef security fill:#f96,stroke:#333,stroke-width:2px;\n    class Proxy,OIDC security;\n</code></pre>\n\n<p>Le diagramme ci-dessus illustre l'architecture de haut niveau d'une implémentation MCP sécurisée. Au cœur de cette architecture se trouve une passerelle API/Proxy comme point de contrôle de sécurité central entre les agents IA et les outils MCP. Le proxy fonctionne en conjonction avec un fournisseur d'identité supportant OIDC pour créer un périmètre de sécurité qui applique l'authentification, l'autorisation et les contrôles d'accès. Cela garantit que toutes les requêtes MCP des agents IA sont correctement authentifiées et autorisées avant d'atteindre les outils MCP réels, qui à leur tour accèdent à divers systèmes backend.</p>\n\n<p>MCP est un standard ouvert (initialement introduit par Anthropic) qui fournit un moyen cohérent pour les assistants IA d'interagir avec des sources de données et des outils externes. Au lieu d'intégrations sur mesure pour chaque système, MCP agit comme un connecteur universel, permettant aux modèles IA de récupérer du contexte ou d'exécuter des tâches via une interface JSON-RPC standardisée. Fait important, MCP a été <strong>conçu avec la sécurité à l'esprit</strong> – rien n'est exposé à l'IA par défaut, et elle n'obtient accès qu'à ce que vous autorisez explicitement. En pratique, cependant, garantir ce principe de « liste d'autorisation » à travers de nombreux outils et utilisateurs nécessite une infrastructure soignée. Une <strong>passerelle API (proxy)</strong> de qualité production peut servir de gardien entre les agents IA (clients MCP) et les outils ou sources de données (serveurs MCP), appliquant les règles d'authentification, d'autorisation et de routage.</p>\n\n<p><em>Avant de plonger dans la solution, une note rapide sur Envoy :</em> il existe des propositions actives pour utiliser Envoy Proxy comme implémentation de référence d'une passerelle MCP. Le routage L7 riche d'Envoy et son extensibilité en font un candidat solide, et il pourrait bientôt inclure un support MCP de première classe. Cela dit, le modèle que nous discutons ici est <strong>agnostique du proxy</strong> – tout proxy inverse HTTP moderne ou passerelle API (Envoy, NGINX, HAProxy, Kong, etc.) offrant des capacités similaires peut être utilisé. L'objectif est de décrire une <em>architecture sécurisée</em> pour MCP, plutôt que les spécificités de la configuration d'Envoy.</p>\n\n<h2>Au-delà des « appels API glorifiés » : le besoin d'une intégration MCP sécurisée</h2>\n\n<p>À première vue, utiliser un outil IA via MCP pourrait sembler aussi simple qu'appeler une API web. Dans une démo basique, un agent LLM pourrait interroger un endpoint REST, obtenir du JSON, et c'est tout. Mais dans un scénario d'entreprise réel, beaucoup plus se passe en coulisses :</p>\n\n<pre><code class=\"language-mermaid\">graph LR\n    subgraph \"Appel API simple\"\n        A[Client] --&gt;|Requête| B[API]\n        B --&gt;|Réponse| A\n    end\n    \n    subgraph \"Réalité MCP d'entreprise\"\n        C[Utilisateur] --&gt;|Interagit| D[Agent IA]\n        D --&gt;|Requête MCP avec identité| E[Passerelle API]\n        E --&gt;|Valider le jeton| F[Fournisseur d'identité]\n        E --&gt;|Router la requête| G[Registre d'outils]\n        E --&gt;|Requête autorisée| H[Outil MCP]\n        H --&gt;|Requête avec contexte utilisateur| I[Système Backend]\n        I --&gt;|Données| H\n        H --&gt;|Réponse| E\n        E --&gt;|Réponse filtrée| D\n        D --&gt;|Résultat| C\n        \n        J[Surveillance de sécurité] -..-&gt;|Audit| E\n    end\n    \n    classDef security fill:#f96,stroke:#333,stroke-width:2px;\n    class E,F,G,J security;\n</code></pre>\n\n<p>Ce diagramme contraste un simple appel API avec la réalité complexe des implémentations MCP d'entreprise. Dans le cas simple, un client fait une requête directe à une API et reçoit une réponse. Cependant, dans la réalité MCP d'entreprise, le flux est beaucoup plus complexe :</p>\n\n<ol>\n<li>Un utilisateur interagit avec un agent IA</li>\n<li>L'agent fait une requête MCP qui inclut le jeton d'identité de l'utilisateur</li>\n<li>La passerelle API valide ce jeton avec un fournisseur d'identité</li>\n<li>La passerelle consulte un registre d'outils pour déterminer le routage</li>\n<li>Si autorisée, la requête est transmise à l'outil MCP approprié</li>\n<li>L'outil interroge les systèmes backend en utilisant le contexte de l'utilisateur</li>\n<li>Les données remontent à travers l'outil vers la passerelle</li>\n<li>La passerelle peut filtrer la réponse selon les politiques de sécurité</li>\n<li>La réponse filtrée atteint l'agent IA</li>\n<li>L'agent présente le résultat à l'utilisateur</li>\n</ol>\n\n<p>Tout au long de ce processus, les systèmes de surveillance de sécurité auditent les interactions au niveau de la passerelle. Ce flux complet garantit que l'identité de l'utilisateur, les permissions et les politiques de sécurité sont appliquées à chaque étape, bien au-delà de ce qu'un simple appel API impliquerait.</p>\n\n<ul>\n<li><strong>Identité utilisateur et contrôle d'accès :</strong> Dans une application IA interactive (comme un assistant de chat qui peut interroger des systèmes internes), chaque requête provient d'un utilisateur avec des permissions spécifiques. Le système doit s'assurer que l'IA n'accède qu'aux données ou n'effectue que les actions que l'<em>utilisateur actuel</em> est autorisé à faire. Contrairement à un appel API typique où un utilisateur s'authentifie directement auprès du service, ici l'agent IA appelle au nom de l'utilisateur. Sans mécanisme approprié de propagation d'identité, vous risquez de transformer un simple appel d'outil en une fuite de données sérieuse ou une violation de privilèges.</li>\n<li><strong>Échanges de contexte multi-étapes :</strong> MCP supporte les sessions avec état et les interactions en streaming. Un agent IA pourrait mener une conversation multi-tours, appelant plusieurs outils en séquence et synthétisant leurs sorties. C'est bien au-delà d'un appel API ponctuel. Plus cette chaîne s'allonge, plus le risque d'<strong>empoisonnement du contexte</strong> augmente – où des données erronées ou malveillantes d'une étape influencent les étapes suivantes. Nous avons besoin de garde-fous pour qu'une réponse malveillante d'un outil ne puisse pas tromper le modèle pour qu'il fasse quelque chose de dangereux à l'étape suivante.</li>\n<li><strong>Chaînes de délégation complexes :</strong> En lien avec ce qui précède, considérez quand les outils appellent d'autres outils. Par exemple, une IA pourrait utiliser un outil de « recherche de fichiers » qui lui-même interroge une base de données ou appelle une autre API. Cette chaîne de délégation devrait transmettre les permissions et le contexte de l'utilisateur original <strong>sans</strong> sur-privilégier aucune étape. Chaque saut nécessite une application cohérente de « qui est autorisé à faire quoi », sinon un service intermédiaire pourrait exécuter une action que l'utilisateur n'avait pas l'intention de faire. Gérer ces autorisations déléguées n'est pas trivial.</li>\n<li><strong>Provisionnement dynamique d'outils :</strong> Dans des environnements agiles, de nouveaux outils (serveurs MCP) seront ajoutés fréquemment – pensez à déployer un nouveau microservice et à le rendre immédiatement disponible aux agents IA, ou à permettre l'installation de plugins tiers. Ce dynamisme est excellent pour la flexibilité mais un casse-tête pour la sécurité. Comment vous assurer que chaque nouvel outil répond à vos standards de sécurité ? Comment empêcher l'introduction d'un outil non vérifié ou même malveillant ? Une approche anarchique peut rapidement mener au chaos ou à une violation. Des processus clairement définis d'<strong>intégration, d'enregistrement et d'application de politiques</strong> pour les outils sont nécessaires dès le premier jour.</li>\n</ul>\n\n<p>En bref, une entreprise doit traiter les intégrations d'outils IA avec la même rigueur que toute intégration de service de production – sinon plus. Une <strong>couche de passerelle appropriée</strong> aide à répondre à ces préoccupations en agissant comme un point de contrôle central. Au lieu de coder en dur la confiance dans chaque agent IA ou outil, le proxy impose des politiques de sécurité à l'échelle de l'organisation. Cette approche nous fait passer <em>au-delà de la mentalité « juste appeler une API »</em> vers un modèle structuré où chaque appel MCP est authentifié, autorisé, surveillé et audité.</p>\n\n<h2>Défis de sécurité clés dans les workflows MCP</h2>\n\n<p>Examinons quelques défis de sécurité spécifiques qui surviennent lors du déploiement de MCP à grande échelle, et pourquoi ils importent :</p>\n\n<pre><code class=\"language-mermaid\">graph TD\n    A[Empoisonnement du contexte] --&gt; |atténué par| B[Filtrage de contenu]\n    A --&gt; |atténué par| C[Vérification d'outil]\n    \n    D[Propagation d'identité] --&gt; |résolu avec| E[Auth basée sur jetons]\n    D --&gt; |résolu avec| F[Chaînes de délégation]\n    \n    G[Provisionnement dynamique d'outils] --&gt; |géré par| H[Registre d'outils]\n    G --&gt; |géré par| I[Workflows d'approbation]\n    G --&gt; |géré par| J[Suivi de versions]\n    \n    K[Changements MCP distants] --&gt; |contrôlé par| L[Gouvernance du proxy]\n    \n    subgraph \"Contrôles de sécurité du proxy\"\n        B\n        C\n        E\n        F\n        H\n        I\n        J\n        L\n    end\n    \n    classDef challenge fill:#f66,stroke:#333,stroke-width:2px;\n    classDef solution fill:#6f6,stroke:#333,stroke-width:2px;\n    \n    class A,D,G,K challenge;\n    class B,C,E,F,H,I,J,L solution;\n</code></pre>\n\n<p>Ce diagramme cartographie les défis de sécurité clés dans les workflows MCP (en rouge) vers leurs solutions correspondantes (en vert) qui peuvent être implémentées dans les contrôles de sécurité du proxy. Le diagramme illustre comment :</p>\n\n<ul>\n<li>L'empoisonnement du contexte est atténué par le filtrage de contenu et la vérification d'outil</li>\n<li>Les défis de propagation d'identité sont résolus avec l'authentification basée sur jetons et des chaînes de délégation appropriées</li>\n<li>Les risques de provisionnement dynamique d'outils sont gérés via un registre d'outils, des workflows d'approbation et un suivi de versions</li>\n<li>Les changements MCP distants sont contrôlés par la gouvernance du proxy</li>\n</ul>\n\n<p>En implémentant ces contrôles dans la couche proxy, les organisations peuvent aborder ces défis de sécurité de manière centralisée et cohérente plutôt que d'essayer de les résoudre individuellement pour chaque outil ou agent.</p>\n\n<ul>\n<li><strong>Empoisonnement du contexte :</strong> Parce que MCP permet d'alimenter le contexte du modèle avec des données externes, il existe un risque que les données soient délibérément conçues pour induire en erreur ou exploiter le modèle. Cela pourrait être une forme d'injection de prompt – par exemple, un document récupéré via un outil pourrait contenir des instructions qui détournent le comportement du modèle. Un acteur malveillant pourrait également essayer d'enregistrer un outil qui retourne du contenu toxique ou de fausses informations. L'architecture nécessite des moyens de valider et d'assainir le contexte provenant des outils. Les atténuations peuvent inclure le filtrage de contenu sur les réponses, la vérification des données par rapport aux attentes, ou la restriction des outils que le modèle fait confiance pour certaines requêtes.</li>\n<li><strong>Chaînes de délégation et propagation d'identité :</strong> Comme mentionné, un agent IA agit souvent au nom d'un utilisateur. Quand il appelle un serveur MCP, il devrait transmettre <em>qui</em> est l'utilisateur (ou au moins ce qu'il est autorisé à faire). Si un outil appelle ensuite une API backend, ce backend pourrait également avoir besoin d'identifiants. Cette chaîne de délégation est délicate – vous voulez éviter l'anti-pattern de « partage de mots de passe » ou de coder en dur des clés en clair. Au lieu de cela, les solutions impliquent des jetons et des flux OAuth : par exemple, l'utilisateur consent et un jeton OAuth2/OIDC est émis, l'IA porte ce jeton dans les requêtes MCP, et le serveur MCP peut <strong>le transmettre</strong> à l'API backend (ou l'échanger). Gérer ces jetons et s'assurer qu'ils sont utilisés correctement (et pas par quelqu'un d'autre) est une tâche de sécurité centrale. Le proxy devrait faciliter cela en attachant et validant le contexte d'identité à chaque étape. Il permet également des <strong>politiques RBAC</strong> – par exemple, n'autoriser certaines méthodes d'outil que si le rôle de l'utilisateur est admin.</li>\n</ul>\n\n<pre><code class=\"language-mermaid\">sequenceDiagram\n    participant User as Utilisateur\n    participant AIAgent as Agent IA\n    participant Proxy as Passerelle API\n    participant IdP as Fournisseur d'identité\n    participant Tool as Outil MCP\n    participant Backend as Système Backend\n    \n    User-&gt;&gt;IdP: 1. Authentifier (nom d'utilisateur/mot de passe)\n    IdP-&gt;&gt;User: 2. Émettre jeton OIDC\n    User-&gt;&gt;AIAgent: 3. Interagir avec l'IA (jeton attaché)\n    AIAgent-&gt;&gt;Proxy: 4. Requête MCP avec jeton\n    Proxy-&gt;&gt;IdP: 5. Valider le jeton\n    IdP-&gt;&gt;Proxy: 6. Jeton valide, contient claims/scopes\n    \n    alt Jeton valide avec permissions requises\n        Proxy-&gt;&gt;Tool: 7. Transmettre requête avec contexte utilisateur\n        Tool-&gt;&gt;Backend: 8. Requête avec auth déléguée\n        Backend-&gt;&gt;Tool: 9. Retourner données (filtrées par permissions utilisateur)\n        Tool-&gt;&gt;Proxy: 10. Retourner résultat\n        Proxy-&gt;&gt;AIAgent: 11. Retourner réponse autorisée\n        AIAgent-&gt;&gt;User: 12. Présenter résultat\n    else Jeton invalide ou permissions insuffisantes\n        Proxy-&gt;&gt;AIAgent: 7. Rejeter requête (401/403)\n        AIAgent-&gt;&gt;User: 8. Signaler accès refusé\n    end\n</code></pre>\n\n<p>Ce diagramme de séquence illustre le flux d'authentification et d'autorisation dans un système MCP utilisant OIDC. Le processus commence avec l'utilisateur s'authentifiant auprès d'un fournisseur d'identité et recevant un jeton OIDC. Ce jeton est ensuite attaché aux interactions de l'utilisateur avec l'agent IA. Quand l'agent fait une requête MCP, il inclut ce jeton, que la passerelle API valide avec le fournisseur d'identité.</p>\n\n<p>Si le jeton est valide et contient les permissions nécessaires (claims/scopes), la requête est transmise à l'outil MCP approprié avec le contexte de l'utilisateur. L'outil peut alors interroger les systèmes backend en utilisant l'authentification déléguée, garantissant que les données retournées sont filtrées selon les permissions de l'utilisateur. Le résultat remonte à travers le système vers l'utilisateur.</p>\n\n<p>Si le jeton est invalide ou manque de permissions suffisantes, la requête est rejetée au niveau de la passerelle avec un code d'erreur approprié (401 Non autorisé ou 403 Interdit), et l'agent IA signale ce refus d'accès à l'utilisateur.</p>\n\n<p>Ce flux garantit que l'identité et les permissions de l'utilisateur sont appliquées de manière cohérente tout au long de la chaîne d'interaction, empêchant l'accès non autorisé à des données ou opérations sensibles.</p>\n\n<ul>\n<li><strong>Provisionnement dynamique d'outils :</strong> Dans un écosystème MCP, les outils peuvent aller et venir. Par exemple, une entreprise pourrait rapidement déployer un nouveau serveur MCP pour un ensemble de données spécifique ou intégrer un service tiers via MCP. Sans contrôles, un agent IA pourrait immédiatement commencer à invoquer tout nouvel outil dès qu'il apparaît. C'est risqué – vous pourriez ne pas vouloir qu'un outil nouvellement ajouté soit disponible à tout le monde par défaut, ou il pourrait nécessiter une vérification. Il y a aussi l'aspect configuration : les nouveaux endpoints d'outils devraient être découvrables par l'IA, et la passerelle doit savoir comment les router et quelle auth exiger. Une configuration sécurisée impliquera probablement un <strong>registre d'outils</strong> ou un service de découverte que le proxy consulte, et une approbation administrative pour les outils. Le proxy peut alors automatiquement appliquer l'auth et le routage appropriés pour chaque nouvel outil, plutôt que de compter sur chaque développeur d'agent pour mettre à jour la logique. Cela fournit une couche de gouvernance pour le cycle de vie des outils.</li>\n</ul>\n\n<pre><code class=\"language-mermaid\">sequenceDiagram\n    participant Admin as Administrateur\n    participant Registry as Registre d'outils\n    participant Proxy as Passerelle API\n    participant Tool as Nouvel outil MCP\n    participant AIAgent as Agent IA\n    \n    Admin-&gt;&gt;Tool: 1. Développer nouvel outil MCP\n    Admin-&gt;&gt;Registry: 2. Enregistrer outil (métadonnées, endpoints, exigences auth)\n    Registry-&gt;&gt;Registry: 3. Valider configuration outil\n    Registry-&gt;&gt;Proxy: 4. Mettre à jour configuration routage\n    \n    Note over Registry,Proxy: L'outil est maintenant enregistré mais pas encore approuvé\n    \n    Admin-&gt;&gt;Registry: 5. Approuver outil pour groupes d'utilisateurs spécifiques\n    Registry-&gt;&gt;Proxy: 6. Mettre à jour politiques d'accès\n    \n    Note over AIAgent,Proxy: L'outil est maintenant disponible aux utilisateurs autorisés\n    \n    AIAgent-&gt;&gt;Proxy: 7. Découvrir outils disponibles\n    Proxy-&gt;&gt;AIAgent: 8. Retourner outils approuvés pour l'utilisateur\n    AIAgent-&gt;&gt;Proxy: 9. Appeler nouvel outil\n    Proxy-&gt;&gt;Tool: 10. Router requête si autorisé\n</code></pre>\n\n<p>Ce diagramme de séquence illustre le workflow d'enregistrement et d'approbation d'outils dans un environnement MCP sécurisé. Le processus commence avec un administrateur développant un nouvel outil MCP et l'enregistrant dans le registre d'outils, fournissant métadonnées, endpoints et exigences d'authentification. Le registre valide la configuration de l'outil et met à jour la configuration de routage dans la passerelle API.</p>\n\n<p>À ce stade, l'outil est enregistré mais pas encore approuvé pour utilisation. L'administrateur doit explicitement approuver l'outil pour des groupes d'utilisateurs spécifiques, ce qui déclenche une mise à jour des politiques d'accès dans la passerelle API. Ce n'est qu'alors que l'outil devient disponible aux utilisateurs autorisés.</p>\n\n<p>Quand un agent IA découvre les outils disponibles via le proxy, il ne reçoit que des informations sur les outils qui ont été approuvés pour l'utilisateur actuel. Quand l'agent appelle le nouvel outil, le proxy route la requête vers l'outil seulement si l'utilisateur est autorisé à y accéder.</p>\n\n<p>Ce workflow garantit que les nouveaux outils subissent une vérification et une approbation appropriées avant de pouvoir être utilisés, et que l'accès est restreint aux seuls utilisateurs autorisés. Il centralise également le processus de gouvernance des outils, facilitant la gestion du cycle de vie des outils MCP de manière sécurisée.</p>\n\n<p>En reconnaissant ces défis, les ingénieurs et architectes de sécurité peuvent concevoir des défenses <em>avant</em> que les problèmes ne surviennent. Nous examinons ensuite comment un proxy conscient de l'identité peut fournir ces défenses de manière propre et centralisée.</p>\n\n<h2>Le pattern de proxy conscient de l'identité pour MCP</h2>\n\n<p>Une conception éprouvée dans les architectures cloud consiste à placer un <strong>proxy inverse</strong> (souvent appelé passerelle API) devant vos services. Les systèmes IA basés sur MCP ne font pas exception. En introduisant un proxy intelligent entre les agents IA (clients) et les serveurs MCP (outils/backends), nous créons un entonnoir contrôlé par lequel tout le trafic d'outils IA passe. Ce proxy peut opérer à la couche 7 (couche application), ce qui signifie qu'il comprend HTTP et même les charges utiles JSON, permettant un contrôle fin. Ci-dessous, nous décrivons les rôles clés qu'un tel proxy joue dans la sécurisation de MCP :</p>\n\n<pre><code class=\"language-mermaid\">graph TB\n    subgraph \"Côté client\"\n        User[Utilisateur]\n        AIAgent[Agent IA]\n        User --&gt;|interagit| AIAgent\n    end\n    \n    subgraph \"Couche de sécurité\"\n        Proxy[Passerelle API/Proxy]\n        Auth[Authentification]\n        RBAC[Autorisation/RBAC]\n        Registry[Registre d'outils]\n        Audit[Journalisation d'audit]\n        \n        Proxy --&gt;|utilise| Auth\n        Proxy --&gt;|applique| RBAC\n        Proxy --&gt;|consulte| Registry\n        Proxy --&gt;|génère| Audit\n    end\n    \n    subgraph \"Outils MCP\"\n        Tool1[Recherche de documents]\n        Tool2[Requête base de données]\n        Tool3[Opérations fichiers]\n        Tool4[API externe]\n    end\n    \n    subgraph \"Systèmes Backend\"\n        DB[(Bases de données)]\n        Storage[Stockage fichiers]\n        APIs[APIs internes]\n        External[Services externes]\n    end\n    \n    AIAgent --&gt;|requêtes MCP| Proxy\n    Proxy --&gt;|route vers| Tool1\n    Proxy --&gt;|route vers| Tool2\n    Proxy --&gt;|route vers| Tool3\n    Proxy --&gt;|route vers| Tool4\n    \n    Tool1 --&gt;|lit| DB\n    Tool1 --&gt;|lit| Storage\n    Tool2 --&gt;|interroge| DB\n    Tool3 --&gt;|gère| Storage\n    Tool4 --&gt;|appelle| APIs\n    Tool4 --&gt;|appelle| External\n    \n    classDef security fill:#f96,stroke:#333,stroke-width:2px;\n    class Proxy,Auth,RBAC,Registry,Audit security;\n</code></pre>\n\n<p>Ce diagramme fournit une vue détaillée du pattern de proxy conscient de l'identité pour MCP. L'architecture est divisée en quatre couches principales :</p>\n\n<ol>\n<li><strong>Côté client</strong> : Les utilisateurs interagissent avec les agents IA, qui génèrent des requêtes MCP.</li>\n<li><strong>Couche de sécurité</strong> : La passerelle API/Proxy se situe au centre de la couche de sécurité, travaillant avec les composants d'authentification, d'autorisation/RBAC, de registre d'outils et de journalisation d'audit pour appliquer les politiques de sécurité.</li>\n<li><strong>Outils MCP</strong> : Divers outils comme la recherche de documents, les requêtes de base de données, les opérations sur fichiers et l'accès aux API externes sont disponibles via l'interface MCP.</li>\n<li><strong>Systèmes Backend</strong> : Les sources de données et services réels avec lesquels les outils MCP interagissent, incluant bases de données, stockage de fichiers, APIs internes et services externes.</li>\n</ol>\n\n<p>Toutes les requêtes MCP des agents IA doivent passer par le proxy, qui authentifie les requêtes, applique les politiques RBAC, consulte le registre d'outils pour déterminer le routage, et génère des journaux d'audit. Le proxy route ensuite les requêtes autorisées vers les outils MCP appropriés, qui à leur tour interagissent avec les systèmes backend.</p>\n\n<p>Cette architecture de sécurité centralisée garantit l'application cohérente des politiques de sécurité à travers toutes les interactions MCP, indépendamment des outils utilisés ou des systèmes backend accédés.</p>\n\n<h3>Routage conscient de session et équilibrage de charge</h3>\n\n<p>Contrairement à un simple appel API sans état, les sessions MCP peuvent être de longue durée et impliquer du streaming (Server-Sent Events pour la sortie, etc.). Le proxy devrait s'assurer que toutes les requêtes et réponses appartenant à une session ou conversation donnée sont gérées de manière cohérente. Cela signifie souvent implémenter l'<strong>affinité de session</strong> – si plusieurs instances d'un serveur MCP sont en cours d'exécution, le proxy routera le trafic d'une session donnée vers la même instance à chaque fois. Cela évite les problèmes où, par exemple, l'état de l'outil A (cache en mémoire, fenêtre de contexte, etc.) est perdu parce que la requête 2 est allée vers une instance différente de la requête 1. Les proxies modernes peuvent faire de l'équilibrage de charge conscient de session en utilisant des en-têtes HTTP ou des routes (par exemple, mapper un ID de session ou un ID client dans l'URL vers un backend particulier). De plus, le proxy peut gérer les connexions SSE avec élégance, de sorte que les réponses en streaming ne soient pas accidentellement cassées par des intermédiaires réseau. Si une session doit être reprise ou transférée, la passerelle peut coordonner cela (comme proposé dans les fonctionnalités Envoy à venir pour MCP). En bref, le proxy garantit la fiabilité et la cohérence pour les interactions avec état de MCP, ce qui est crucial pour l'expérience utilisateur et pour maintenir un contexte correct.</p>\n\n<pre><code class=\"language-mermaid\">sequenceDiagram\n    participant User as Utilisateur\n    participant AIAgent as Agent IA\n    participant Proxy as Passerelle API\n    participant Instance1 as Instance outil 1\n    participant Instance2 as Instance outil 2\n    \n    User-&gt;&gt;AIAgent: Démarrer conversation\n    AIAgent-&gt;&gt;Proxy: Requête MCP 1 (session=abc123)\n    \n    Note over Proxy: Routage par affinité de session\n    \n    Proxy-&gt;&gt;Instance1: Router vers instance 1\n    Instance1-&gt;&gt;Proxy: Réponse avec état\n    Proxy-&gt;&gt;AIAgent: Retourner réponse\n    \n    User-&gt;&gt;AIAgent: Continuer conversation\n    AIAgent-&gt;&gt;Proxy: Requête MCP 2 (session=abc123)\n    \n    Note over Proxy: Même ID de session route vers même instance\n    \n    Proxy-&gt;&gt;Instance1: Router vers instance 1 (préserve l'état)\n    Instance1-&gt;&gt;Proxy: Réponse avec état mis à jour\n    Proxy-&gt;&gt;AIAgent: Retourner réponse\n    \n    Note over User,Instance2: Sans affinité de session, la requête pourrait aller vers instance 2 et perdre l'état\n</code></pre>\n\n<p>Ce diagramme de séquence illustre comment l'affinité de session fonctionne dans un environnement MCP. Quand un utilisateur démarre une conversation avec un agent IA, l'agent fait une requête MCP à la passerelle API avec un identifiant de session (dans ce cas, \"abc123\"). La passerelle utilise cet ID de session pour router la requête vers une instance d'outil spécifique (Instance 1).</p>\n\n<p>Quand l'utilisateur continue la conversation, l'agent fait une autre requête MCP avec le même ID de session. Parce que la passerelle implémente l'affinité de session, elle route cette requête vers la même instance (Instance 1), qui préserve l'état de l'interaction précédente. Cela garantit une expérience cohérente et cohérente pour l'utilisateur.</p>\n\n<p>Sans affinité de session, la deuxième requête pourrait être routée vers une instance différente (Instance 2), qui n'aurait pas les informations d'état de la première requête. Cela résulterait en une expérience cassée, car l'outil n'aurait pas le contexte de l'interaction précédente.</p>\n\n<p>L'affinité de session est particulièrement importante pour MCP car de nombreuses interactions IA sont avec état et dépendantes du contexte. La capacité du proxy à maintenir cette cohérence de session est un avantage clé par rapport aux approches d'intégration API plus simples.</p>\n\n<h3>Intégration JWT et OIDC pour l'authentification</h3>\n\n<p>Chaque requête atteignant la passerelle MCP devrait porter un jeton d'identité valide – typiquement un JSON Web Token (JWT) émis par un fournisseur d'identité via OIDC (OpenID Connect). En exigeant des JWT, le proxy décharge l'authentification des outils eux-mêmes et garantit que seuls les appels authentifiés et autorisés passent. En pratique, cela signifie que l'agent IA (ou la session de l'utilisateur avec l'agent) doit obtenir un jeton OIDC (par exemple, un jeton ID ou un jeton d'accès) et l'attacher à chaque requête MCP (souvent dans un en-tête HTTP comme <code>Authorization: Bearer &lt;token&gt;</code>). Le proxy vérifie ce jeton, vérifie la signature et les claims (émetteur, audience, expiration, etc.), et rejette toute requête qui n'est pas correctement authentifiée. De cette façon, vos serveurs MCP ne voient jamais un appel anonyme – ils font confiance à la passerelle pour avoir vérifié l'identité.</p>\n\n<pre><code class=\"language-mermaid\">sequenceDiagram\n    participant User as Utilisateur\n    participant App as Application IA\n    participant IdP as Fournisseur d'identité\n    participant Proxy as Passerelle API\n    participant Tool as Outil MCP\n    \n    User-&gt;&gt;App: Accéder à l'application IA\n    App-&gt;&gt;IdP: Rediriger vers connexion\n    User-&gt;&gt;IdP: S'authentifier\n    IdP-&gt;&gt;App: Code d'autorisation\n    App-&gt;&gt;IdP: Échanger code contre jetons\n    IdP-&gt;&gt;App: Jeton ID + jeton d'accès\n    \n    Note over App: Stocker jetons de manière sécurisée\n    \n    User-&gt;&gt;App: Requête utilisant outil IA\n    App-&gt;&gt;Proxy: Requête MCP avec jeton d'accès\n    \n    Proxy-&gt;&gt;Proxy: Valider jeton (signature, expiration, audience)\n    Proxy-&gt;&gt;Proxy: Extraire identité et permissions utilisateur\n    \n    alt Jeton valide\n        Proxy-&gt;&gt;Tool: Transmettre requête avec contexte utilisateur\n        Tool-&gt;&gt;Proxy: Réponse\n        Proxy-&gt;&gt;App: Retourner réponse\n        App-&gt;&gt;User: Afficher résultat\n    else Jeton invalide\n        Proxy-&gt;&gt;App: 401 Non autorisé\n        App-&gt;&gt;User: Session expirée, veuillez vous reconnecter\n    end\n    \n    Note over App,Proxy: Le rafraîchissement du jeton se fait en arrière-plan\n    App-&gt;&gt;IdP: Rafraîchir jeton quand nécessaire\n    IdP-&gt;&gt;App: Nouveau jeton d'accès\n</code></pre>\n\n<p>Ce diagramme de séquence illustre le flux d'authentification OIDC dans un environnement MCP. Le processus commence quand un utilisateur accède à l'application IA, qui redirige vers le fournisseur d'identité pour l'authentification. Après que l'utilisateur s'authentifie, le fournisseur d'identité émet un code d'autorisation, que l'application échange contre des jetons ID et d'accès.</p>\n\n<p>L'application stocke ces jetons de manière sécurisée et utilise le jeton d'accès lors de requêtes MCP via l'agent IA. Quand le proxy reçoit une requête, il valide le jeton en vérifiant la signature, l'expiration, l'audience et d'autres claims. Il extrait également l'identité et les permissions de l'utilisateur du jeton.</p>\n\n<p>Si le jeton est valide, le proxy transmet la requête à l'outil MCP approprié avec le contexte de l'utilisateur. L'outil traite la requête et retourne une réponse, qui remonte à travers le proxy vers l'application et finalement vers l'utilisateur.</p>\n\n<p>Si le jeton est invalide (expiré, altéré, etc.), le proxy retourne une réponse 401 Non autorisé, et l'application invite l'utilisateur à se reconnecter.</p>\n\n<p>En arrière-plan, l'application peut utiliser un jeton de rafraîchissement pour obtenir de nouveaux jetons d'accès quand nécessaire, sans exiger que l'utilisateur se ré-authentifie. Cela garantit une expérience utilisateur fluide tout en maintenant la sécurité.</p>\n\n<p>Cette intégration OIDC fournit un mécanisme d'authentification robuste largement adopté dans les environnements d'entreprise et s'intègre bien avec les systèmes de gestion d'identité existants.</p>\n\n<h3>Introduction d'OIDC-A pour l'identité des agents et outils</h3>\n\n<p>Alors que la discussion ci-dessus se concentre sur l'authentification de l'<strong>utilisateur humain</strong>, un déploiement MCP de qualité production doit également identifier deux acteurs supplémentaires :</p>\n\n<ol>\n<li>L'<em>agent LLM</em> qui orchestre le workflow.</li>\n<li>L'<em>outil / ressource MCP</em> qui est invoqué sur le backend.</li>\n</ol>\n\n<p>Notre article compagnon \"<strong>Proposition OpenID Connect pour Agents (OIDC-A) 1.0</strong>\" ({{ site.baseurl }}/2025/04/28/oidc-a-proposal/) étend OIDC Core 1.0 avec un ensemble riche de claims pour l'<strong>identité d'agent, l'attestation et les chaînes de délégation</strong>. En pratique, cela signifie :</p>\n\n<ul>\n<li>Quand un agent IA démarre une session, il obtient un <strong>jeton ID</strong> qui contient les claims OIDC-A (<code>agent_type</code>, <code>agent_model</code>, <code>agent_instance_id</code>, <code>delegator_sub</code>, <code>delegation_chain</code>, etc.). Ce jeton voyage aux côtés du jeton d'accès de l'utilisateur dans chaque requête MCP.</li>\n<li>Les outils MCP peuvent également exposer leur propre identité OIDC (ou se voir émettre un <em>jeton de ressource</em> signé) qui annonce des métadonnées telles que les capacités de l'outil, la version et le niveau de confiance (<code>agent_capabilities</code>, <code>agent_trust_level</code>, <code>agent_attestation</code>).</li>\n<li>La passerelle valide maintenant jusqu'à <strong>trois</strong> identités sur chaque appel – <strong>utilisateur → agent → outil</strong> – formant une <em>chaîne de délégation</em> explicite qui peut être évaluée contre les politiques RBAC et de conformité.</li>\n</ul>\n\n<p>L'adoption d'OIDC-A apporte plusieurs avantages :</p>\n\n<ul>\n<li>Identité de bout en bout, cryptographiquement vérifiable pour tout ce qui touche le chemin de requête.</li>\n<li>Autorisation fine basée sur les capacités de l'agent ou de l'outil (par exemple, n'autoriser que les agents qui annoncent la capacité <code>email:draft</code> à invoquer l'outil Mail).</li>\n<li>L'attestation intégrée (<code>agent_attestation</code>) permet à la passerelle de vérifier l'intégrité et la provenance des agents et des outils avant de router le trafic vers eux.</li>\n</ul>\n\n<p>Pour le reste de cet article, chaque fois que nous faisons référence à un \"jeton\" validé par la passerelle, supposez que cela englobe maintenant <strong>le jeton de l'utilisateur, le jeton OIDC-A de l'agent, et (optionnellement) le jeton d'outil/ressource</strong> – tous évalués dans une seule étape de décision de politique.</p>\n\n<p>Ce pattern est déjà largement utilisé dans la sécurité API : <em>\"une passerelle API peut implémenter de manière sécurisée et cohérente l'authentification... sans alourdir les applications elles-mêmes.\"</em> Dans notre contexte, le proxy MCP pourrait s'intégrer avec votre SSO d'entreprise (Azure AD, Okta, etc.) via OIDC pour gérer les flux de connexion utilisateur et la validation de jetons. De nombreuses passerelles supportent OIDC nativement, initiant des redirections pour la connexion utilisateur si nécessaire et stockant ensuite le jeton résultant dans un cookie pour la continuité de session. Dans un scénario d'agent sans tête (où l'IA appelle des outils serveur à serveur), le jeton pourrait être provisionné hors bande (par exemple, l'utilisateur s'est connecté à l'application IA, donc l'application injecte le jeton pour que l'agent l'utilise). Dans tous les cas, la passerelle applique que <strong>pas de jeton = pas d'accès</strong>. Elle peut également mapper les claims de jeton aux rôles ou scopes pour implémenter l'autorisation (par exemple, seuls les utilisateurs avec un scope \"HR_read\" peuvent utiliser l'outil \"Base de données RH\"). Cela s'aligne parfaitement avec l'objectif de conception de MCP de connexions sécurisées – combiner MCP avec OIDC et OIDC-A vous donne un canal authentifié de bout en bout pour l'utilisation d'outils.</p>\n\n<pre><code class=\"language-mermaid\">sequenceDiagram\n    participant User as Utilisateur\n    participant Agent as Agent LLM (OIDC-A)\n    participant Proxy as Passerelle API\n    participant Tool as Outil MCP (OIDC-A)\n    participant Backend as Système Backend\n\n    User-&gt;&gt;Agent: 1. Interagir (chat, formulaire, etc.)\n    Agent-&gt;&gt;Proxy: 2. Requête MCP\\nBearer jeton utilisateur + jeton OIDC-A agent\n    Proxy-&gt;&gt;Proxy: 3. Valider jeton utilisateur (OIDC) &amp; jeton agent (OIDC-A)\n    Proxy--&gt;&gt;Tool: 4. Transmettre requête plus *jeton ressource* optionnel pour l'outil\n    Tool-&gt;&gt;Backend: 5. Requête/action utilisant auth déléguée\n    Backend--&gt;&gt;Tool: 6. Données / résultat\n    Tool--&gt;&gt;Proxy: 7. Réponse (peut inclure attestation)\n    Proxy--&gt;&gt;Agent: 8. Réponse autorisée\n    Agent--&gt;&gt;User: 9. Présenter résultat\n</code></pre>\n\n<h3>Filtrage de métadonnées d'outils et application de politiques</h3>\n\n<p>Un avantage puissant du proxy est qu'il peut prendre des décisions de routage basées non seulement sur les URL, mais sur les <em>métadonnées</em> dans les requêtes. Avec MCP, les requêtes et réponses sont au format JSON-RPC, qui inclut des champs comme le nom de méthode de l'outil, les paramètres, et même les annotations d'outil. Un proxy conscient de l'identité peut être configuré pour inspecter ces détails et appliquer des <strong>règles de politique</strong>. Par exemple, vous pourriez configurer des règles telles que :</p>\n\n<pre><code class=\"language-mermaid\">graph TD\n    subgraph \"Requête MCP\"\n        Request[Requête JSON-RPC]\n        Method[Méthode outil]\n        Params[Paramètres]\n        User[Identité utilisateur]\n    end\n    \n    subgraph \"Moteur de politiques\"\n        Rules[Règles de politique]\n        RBAC[Accès basé sur rôles]\n        Audit[Journalisation d'audit]\n        Transform[Transformation de réponse]\n    end\n    \n    Request --&gt; Method\n    Request --&gt; Params\n    Request --&gt; User\n    \n    Method --&gt; Rules\n    Params --&gt; Rules\n    User --&gt; RBAC\n    \n    Rules --&gt; Decision{Autoriser/Refuser}\n    RBAC --&gt; Decision\n    \n    Decision --&gt;|Autoriser| Forward[Transmettre à l'outil]\n    Decision --&gt;|Refuser| Reject[Rejeter requête]\n    \n    Forward --&gt; Audit\n    Reject --&gt; Audit\n    \n    Forward --&gt; Tool[Outil MCP]\n    Tool --&gt; Response[Réponse outil]\n    Response --&gt; Transform\n    Transform --&gt; Filtered[Réponse filtrée]\n    \n    classDef request fill:#bbf,stroke:#333,stroke-width:1px;\n    classDef policy fill:#fbf,stroke:#333,stroke-width:1px;\n    classDef action fill:#bfb,stroke:#333,stroke-width:1px;\n    \n    class Request,Method,Params,User request;\n    class Rules,RBAC,Audit,Transform policy;\n    class Decision,Forward,Reject,Filtered action;\n</code></pre>\n\n<p>Ce diagramme illustre comment le filtrage de métadonnées d'outils et l'application de politiques fonctionnent dans un proxy MCP. Le processus commence avec une requête MCP au format JSON-RPC, qui contient la méthode d'outil, les paramètres et les informations d'identité utilisateur. Ces composants sont extraits et alimentés dans le moteur de politiques.</p>\n\n<p>Le moteur de politiques se compose de règles de politique, de contrôle d'accès basé sur les rôles (RBAC), de journalisation d'audit et de composants de transformation de réponse. La méthode d'outil et les paramètres sont évalués par rapport aux règles de politique, tandis que l'identité utilisateur est vérifiée par rapport aux permissions RBAC.</p>\n\n<p>Sur la base de ces évaluations, le moteur de politiques prend une décision autoriser/refuser. Si la requête est autorisée, elle est transmise à l'outil MCP ; si refusée, elle est rejetée. Dans les deux cas, l'action est journalisée à des fins d'audit.</p>\n\n<p>Quand une requête est autorisée et traitée par l'outil, la réponse peut passer par une étape de transformation avant d'être retournée au client. Cette transformation peut filtrer ou modifier la réponse selon les politiques de sécurité, comme supprimer des informations sensibles que l'utilisateur ne devrait pas voir.</p>\n\n<p>Cette application de politique fine au niveau des métadonnées permet des contrôles de sécurité sophistiqués qui vont bien au-delà du simple routage basé sur URL. Par exemple :</p>\n\n<ul>\n<li><em>\"Si l'appel d'outil est <code>delete_file</code> et que l'utilisateur n'est pas dans le groupe IT Admin, refuser la requête.\"</em></li>\n<li><em>\"N'autoriser l'outil <code>execute_sql</code> que les jours de semaine entre 9h et 17h, et journaliser toutes les requêtes.\"</em></li>\n<li><em>\"Si un outil est marqué comme contenant des données sensibles, s'assurer que la réponse est assainie ou chiffrée.\"</em></li>\n</ul>\n\n<p>C'est analogue à un pare-feu d'application web (WAF) ou une passerelle API effectuant du filtrage de contenu, mais adapté à l'utilisation d'outils IA. Dans la proposition Envoy MCP, cela correspond à l'analyse des messages MCP et à l'utilisation de filtres RBAC sur eux. Le proxy comprend essentiellement l'<em>intention</em> de chaque appel d'outil et peut le contrôler de manière appropriée. Il peut également redacter ou transformer les données si nécessaire – par exemple, supprimer certains champs d'une réponse que l'utilisateur ne devrait pas voir, ou masquer des informations personnellement identifiables. En centralisant cela dans la passerelle, vous évitez d'avoir à implémenter des vérifications dans chaque service d'outil (qui pourraient être incohérentes ou oubliées). L'<strong>audit</strong> est un autre avantage : le proxy peut journaliser chaque invocation d'outil avec l'identité utilisateur et les paramètres, alimentant les systèmes SIEM pour la surveillance. De cette façon, si une IA fait un jour quelque chose qu'elle ne devrait pas, vous avez une trace claire de quel appel d'outil était impliqué et qui l'a déclenché. En somme, le filtrage basé sur les métadonnées transforme le proxy en un point d'application de politique intelligent, ajoutant une couche de sécurité au-dessus des capacités de base de MCP.</p>\n\n<h3>Routage conscient de version et de contexte</h3>\n\n<p>Les entreprises font constamment évoluer leurs services – nouvelles versions, tests A/B, déploiements staging vs production, etc. Le proxy peut grandement simplifier la façon dont les agents IA gèrent ces changements. Au lieu que l'IA ait besoin de savoir quelle version d'un outil appeler, la passerelle peut implémenter un <strong>routage conscient de version</strong>. Par exemple, l'endpoint MCP pour un outil \"Recherche de documents\" pourrait rester le même pour l'agent, mais le proxy pourrait router 90% des requêtes vers v1 du service et 10% vers une nouvelle v2 (pour un déploiement canari). Ou router les utilisateurs internes vers une instance \"beta\" tandis que les utilisateurs externes vont vers stable. Cela se fait en faisant correspondre les attributs de requête ou en utilisant des règles de routage qui incluent l'audience utilisateur et les identifiants d'outil.</p>\n\n<pre><code class=\"language-mermaid\">graph TB\n    AIAgent[Agent IA] --&gt;|Requête MCP| Proxy[Passerelle API]\n    \n    Proxy --&gt;|\"90% trafic\"| V1[Outil v1]\n    Proxy --&gt;|\"10% trafic\"| V2[Outil v2 - Canari]\n    \n    Proxy --&gt;|\"Utilisateurs internes\"| Beta[Version Beta]\n    Proxy --&gt;|\"Utilisateurs externes\"| Stable[Version Stable]\n    \n    Proxy --&gt;|\"Petites requêtes\"| Standard[Instance standard]\n    Proxy --&gt;|\"Grandes requêtes\"| HighMem[Instance haute mémoire]\n    \n    Proxy --&gt;|\"Utilisateurs US\"| US[Région US]\n    Proxy --&gt;|\"Utilisateurs EU\"| EU[Région EU]\n    \n    classDef proxy fill:#f96,stroke:#333,stroke-width:2px;\n    classDef version fill:#bbf,stroke:#333,stroke-width:1px;\n    classDef audience fill:#bfb,stroke:#333,stroke-width:1px;\n    classDef size fill:#fbf,stroke:#333,stroke-width:1px;\n    classDef region fill:#ff9,stroke:#333,stroke-width:1px;\n    \n    class Proxy proxy;\n    class V1,V2 version;\n    class Beta,Stable audience;\n    class Standard,HighMem size;\n    class US,EU region;\n</code></pre>\n\n<p>Ce diagramme illustre les diverses stratégies de routage qu'une passerelle API peut implémenter pour les requêtes MCP. La passerelle peut router le trafic selon plusieurs facteurs :</p>\n\n<ol>\n<li><strong>Routage basé sur version</strong> : La passerelle peut diviser le trafic entre différentes versions d'un outil, comme envoyer 90% vers v1 et 10% vers un déploiement canari de v2. Cela permet des déploiements progressifs et des tests A/B sans nécessiter de changements aux agents IA.</li>\n<li><strong>Routage basé sur audience</strong> : Les utilisateurs internes peuvent être dirigés vers des versions beta d'outils, tandis que les utilisateurs externes sont routés vers des versions stables. Cela permet des tests et validations internes avant une diffusion plus large.</li>\n<li><strong>Routage basé sur taille de requête</strong> : Les petites requêtes peuvent être gérées par des instances standard, tandis que les grandes requêtes nécessitant plus de ressources sont dirigées vers des instances haute mémoire. Cela optimise l'utilisation des ressources et garantit que les requêtes exigeantes n'impactent pas les performances des opérations standard.</li>\n<li><strong>Routage géographique</strong> : Les utilisateurs de différentes régions peuvent être dirigés vers des instances spécifiques à la région, réduisant la latence et potentiellement répondant aux exigences de résidence des données.</li>\n</ol>\n\n<p>L'agent IA n'a pas besoin d'être conscient de ces décisions de routage ; il fait simplement des requêtes au nom logique de l'outil, et la passerelle gère la complexité du routage vers le backend approprié. Cette abstraction simplifie l'implémentation de l'agent tout en fournissant de puissantes capacités opérationnelles.</p>\n\n<p>De même, le routage peut considérer le <strong>contexte</strong> – par exemple, diriger les requêtes vers le serveur régional le plus proche pour une latence plus faible si la localisation de l'utilisateur est connue, ou choisir un backend différent selon la taille de la requête (peut-être une instance spéciale haute mémoire pour de très gros fichiers). Tout cela est configurable au niveau du proxy. L'agent IA appelle simplement le nom logique de l'outil, et la passerelle se charge de trouver le bon backend. Cela facilite non seulement les opérations (vous pouvez mettre à niveau les outils backend sans casser l'interface de l'IA), mais ajoute également à la sécurité. Vous pourriez isoler certaines versions pour les tests, ou vous assurer que les outils expérimentaux ne sont accessibles que sous certaines conditions. En contrôlant le flux de trafic, le proxy aide à maintenir un <strong>principe de moindre privilège</strong> à l'échelle macro – l'IA n'atteint que les backends qu'elle est censée atteindre, via des routes appropriées au contexte actuel.</p>\n\n<h2>Implémentation de la sécurité MCP avec un proxy : une approche pratique</h2>\n\n<p>Maintenant que nous avons couvert les patterns de sécurité clés, examinons une approche pratique pour implémenter la sécurité MCP avec un proxy conscient de l'identité. Cette section décrit les étapes pour configurer un environnement MCP sécurisé, en se concentrant sur les points d'intégration entre les composants.</p>\n\n<pre><code class=\"language-mermaid\">graph TB\n    subgraph ImplementationSteps[\"Étapes d'implémentation\"]\n        Step1[1. Configurer fournisseur d'identité]\n        Step2[2. Configurer passerelle API]\n        Step3[3. Implémenter registre d'outils]\n        Step4[4. Définir politiques de sécurité]\n        Step5[5. Intégrer agents IA]\n        Step6[6. Surveiller et auditer]\n        \n        Step1 --&gt; Step2\n        Step2 --&gt; Step3\n        Step3 --&gt; Step4\n        Step4 --&gt; Step5\n        Step5 --&gt; Step6\n    end\n    \n    classDef step fill:#beb,stroke:#333,stroke-width:1px\n    class Step1,Step2,Step3,Step4,Step5,Step6 step\n</code></pre>\n\n<p>Ce diagramme décrit les six étapes clés de l'implémentation de la sécurité MCP avec un proxy. Le processus suit une progression logique :</p>\n\n<ol>\n<li><strong>Configurer fournisseur d'identité</strong> : Établir la fondation pour l'authentification et l'autorisation.</li>\n<li><strong>Configurer passerelle API</strong> : Mettre en place le point de contrôle de sécurité central.</li>\n<li><strong>Implémenter registre d'outils</strong> : Créer un système pour gérer les outils MCP.</li>\n<li><strong>Définir politiques de sécurité</strong> : Établir les règles pour le contrôle d'accès et la protection des données.</li>\n<li><strong>Intégrer agents IA</strong> : Connecter les agents IA à l'environnement MCP sécurisé.</li>\n<li><strong>Surveiller et auditer</strong> : Suivre et examiner en continu l'activité du système.</li>\n</ol>\n\n<p>Chaque étape s'appuie sur les précédentes, créant une implémentation de sécurité complète. Les sections suivantes exploreront chaque étape en détail.</p>\n\n<h3>1. Configuration du fournisseur d'identité</h3>\n\n<p>La première étape consiste à configurer votre fournisseur d'identité (IdP) pour supporter les flux OIDC nécessaires à la sécurité MCP. Cela implique typiquement :</p>\n\n<ol>\n<li>Créer une application OIDC dans votre IdP (par exemple, Azure AD, Okta, Auth0)</li>\n<li>Configurer les scopes et claims appropriés</li>\n<li>Configurer les URI de redirection pour votre application IA</li>\n<li>Générer les identifiants client (ID client et secret)</li>\n</ol>\n\n<p>L'IdP sera responsable de l'authentification des utilisateurs et de l'émission des jetons qui seront utilisés pour sécuriser les requêtes MCP. Il est important de configurer les scopes et claims appropriés pour s'assurer que les jetons contiennent les informations nécessaires aux décisions d'autorisation.</p>\n\n<h3>2. Configuration de la passerelle API</h3>\n\n<p>Ensuite, vous devrez configurer votre passerelle API pour agir comme proxy MCP. Cela implique :</p>\n\n<pre><code class=\"language-mermaid\">sequenceDiagram\n    participant Admin as Administrateur\n    participant Gateway as Passerelle API\n    participant IdP as Fournisseur d'identité\n    \n    Admin-&gt;&gt;Gateway: 1. Configurer intégration OIDC\n    Gateway-&gt;&gt;IdP: 2. Récupérer document de découverte OIDC\n    IdP-&gt;&gt;Gateway: 3. Retourner endpoints et clés\n    \n    Admin-&gt;&gt;Gateway: 4. Configurer règles de routage MCP\n    Admin-&gt;&gt;Gateway: 5. Configurer politiques de sécurité\n    \n    Note over Gateway: Passerelle prête à valider jetons et router trafic MCP\n</code></pre>\n\n<p>Ce diagramme de séquence illustre le processus de configuration d'une passerelle API pour la sécurité MCP. Le processus commence avec un administrateur configurant l'intégration OIDC dans la passerelle. La passerelle récupère ensuite le document de découverte OIDC du fournisseur d'identité, qui retourne les endpoints et clés nécessaires pour la validation de jetons.</p>\n\n<p>Ensuite, l'administrateur configure les règles de routage MCP, définissant comment les requêtes doivent être dirigées vers différents outils MCP selon divers critères. L'administrateur configure également les politiques de sécurité, spécifiant qui peut accéder à quels outils et sous quelles conditions.</p>\n\n<p>Une fois ces configurations terminées, la passerelle est prête à valider les jetons et router le trafic MCP selon les règles et politiques définies. Cette configuration établit la passerelle comme point de contrôle de sécurité central pour toutes les interactions MCP.</p>\n\n<p>Les étapes de configuration incluent :</p>\n\n<ol>\n<li>Configurer l'intégration OIDC, incluant la configuration des paramètres de validation de jetons (émetteur, audience, etc.)</li>\n<li>Définir les règles de routage pour les requêtes MCP</li>\n<li>Configurer les politiques de sécurité pour l'accès aux outils</li>\n<li>Configurer la journalisation d'audit</li>\n</ol>\n\n<p>La passerelle sera responsable de valider les jetons, d'appliquer les politiques de sécurité et de router les requêtes MCP vers les backends appropriés. Il est important de s'assurer que la passerelle est correctement configurée pour gérer le format JSON-RPC de MCP et pour extraire les informations nécessaires aux décisions de politique.</p>\n\n<h3>3. Implémentation du registre d'outils</h3>\n\n<p>Un registre d'outils est essentiel pour gérer le cycle de vie des outils MCP dans votre environnement. Cela implique :</p>\n\n<ol>\n<li>Créer une base de données ou un service pour stocker les métadonnées d'outils</li>\n<li>Définir le processus d'enregistrement pour les nouveaux outils</li>\n<li>Implémenter le workflow d'approbation pour l'accès aux outils</li>\n<li>Intégrer le registre avec la passerelle API</li>\n</ol>\n\n<p>Le registre d'outils sera responsable de maintenir la liste des outils disponibles, leurs endpoints et leurs exigences d'accès. Il fournira également les informations nécessaires à la passerelle API pour le routage et l'application de politiques.</p>\n\n<pre><code class=\"language-mermaid\">graph TB\n    subgraph \"Registre d'outils\"\n        DB[(Base de données outils)]\n        API[API registre]\n        UI[Interface admin]\n        \n        UI --&gt;|Gérer outils| API\n        API --&gt;|Opérations CRUD| DB\n    end\n    \n    subgraph \"Points d'intégration\"\n        Gateway[Passerelle API]\n        Agents[Agents IA]\n        \n        API --&gt;|Configurations outils| Gateway\n        API --&gt;|Outils disponibles| Agents\n    end\n    \n    subgraph \"Cycle de vie outil\"\n        Register[Enregistrer]\n        Approve[Approuver]\n        Deploy[Déployer]\n        Monitor[Surveiller]\n        Retire[Retirer]\n        \n        Register --&gt; Approve\n        Approve --&gt; Deploy\n        Deploy --&gt; Monitor\n        Monitor --&gt; Retire\n    end\n    \n    classDef registry fill:#bbf,stroke:#333,stroke-width:1px;\n    classDef integration fill:#fbf,stroke:#333,stroke-width:1px;\n    classDef lifecycle fill:#bfb,stroke:#333,stroke-width:1px;\n    \n    class DB,API,UI registry;\n    class Gateway,Agents integration;\n    class Register,Approve,Deploy,Monitor,Retire lifecycle;\n</code></pre>\n\n<p>Ce diagramme illustre les composants et le cycle de vie d'un registre d'outils dans un environnement MCP. Le registre d'outils se compose de trois composants principaux :</p>\n\n<ol>\n<li><strong>Base de données outils</strong> : Stocke les métadonnées sur tous les outils MCP enregistrés, incluant leurs endpoints, versions, exigences d'accès et statut.</li>\n<li><strong>API registre</strong> : Fournit un accès programmatique à la base de données d'outils, permettant des opérations CRUD sur les enregistrements d'outils.</li>\n<li><strong>Interface admin</strong> : Permet aux administrateurs de gérer les outils via une interface utilisateur, incluant l'enregistrement, l'approbation et la surveillance.</li>\n</ol>\n\n<p>Le registre d'outils s'intègre avec deux systèmes clés :</p>\n\n<ul>\n<li><strong>Passerelle API</strong> : Reçoit les configurations d'outils du registre, qui informent les décisions de routage et de politique.</li>\n<li><strong>Agents IA</strong> : Découvrent les outils disponibles via le registre, selon les permissions utilisateur et le statut des outils.</li>\n</ul>\n\n<p>Le diagramme montre également le cycle de vie d'un outil MCP :</p>\n\n<ol>\n<li><strong>Enregistrer</strong> : Un nouvel outil est enregistré dans le système avec ses métadonnées.</li>\n<li><strong>Approuver</strong> : L'outil subit une révision et est approuvé pour utilisation par des groupes d'utilisateurs spécifiques.</li>\n<li><strong>Déployer</strong> : L'outil est rendu disponible dans l'environnement de production.</li>\n<li><strong>Surveiller</strong> : L'utilisation et les performances de l'outil sont surveillées.</li>\n<li><strong>Retirer</strong> : Quand il n'est plus nécessaire, l'outil est retiré du système.</li>\n</ol>\n\n<p>Cette approche complète de la gestion des outils garantit que tous les outils MCP sont correctement vérifiés, déployés et surveillés tout au long de leur cycle de vie, réduisant les risques de sécurité et les problèmes opérationnels.</p>\n\n<h3>4. Définition des politiques de sécurité</h3>\n\n<p>Les politiques de sécurité sont les règles qui régissent l'accès aux outils MCP. Cela implique :</p>\n\n<ol>\n<li>Définir les politiques RBAC pour l'accès aux outils</li>\n<li>Configurer les règles de filtrage de contenu pour les réponses</li>\n<li>Configurer les exigences de journalisation d'audit</li>\n<li>Implémenter les politiques de contrôle de version</li>\n</ol>\n\n<p>Les politiques de sécurité seront appliquées par la passerelle API selon l'identité de l'utilisateur et l'outil accédé. Il est important de s'assurer que les politiques sont complètes et alignées avec les exigences de sécurité de votre organisation.</p>\n\n<h3>5. Intégration des agents IA</h3>\n\n<p>Enfin, vous devrez intégrer vos agents IA avec l'environnement MCP sécurisé. Cela implique :</p>\n\n<ol>\n<li>Configurer les agents pour obtenir et utiliser les jetons OIDC</li>\n<li>Implémenter la fonctionnalité client MCP</li>\n<li>Gérer les erreurs d'authentification et d'autorisation</li>\n<li>Gérer le rafraîchissement de jetons et la continuité de session</li>\n</ol>\n\n<p>Les agents IA seront responsables d'obtenir les jetons nécessaires et de les inclure dans les requêtes MCP. Ils devront également gérer les erreurs d'authentification et d'autorisation avec élégance, fournissant un retour approprié aux utilisateurs.</p>\n\n<pre><code class=\"language-mermaid\">sequenceDiagram\n    participant User as Utilisateur\n    participant Agent as Agent IA\n    participant App as Application\n    participant IdP as Fournisseur d'identité\n    participant Gateway as Passerelle API\n    participant Tool as Outil MCP\n    \n    User-&gt;&gt;App: Accéder à l'application IA\n    App-&gt;&gt;IdP: Authentifier utilisateur\n    IdP-&gt;&gt;App: Émettre jetons\n    \n    User-&gt;&gt;Agent: Requête utilisant capacités IA\n    Agent-&gt;&gt;App: Demander jeton pour MCP\n    App-&gt;&gt;Agent: Fournir jeton\n    \n    Agent-&gt;&gt;Gateway: Requête MCP avec jeton\n    Gateway-&gt;&gt;Gateway: Valider jeton &amp; appliquer politiques\n    Gateway-&gt;&gt;Tool: Transmettre requête autorisée\n    Tool-&gt;&gt;Gateway: Réponse\n    Gateway-&gt;&gt;Agent: Retourner réponse\n    Agent-&gt;&gt;User: Présenter résultat\n    \n    Note over App,Gateway: Cycle de rafraîchissement de jeton\n    App-&gt;&gt;IdP: Rafraîchir jeton quand nécessaire\n    IdP-&gt;&gt;App: Nouveau jeton d'accès\n</code></pre>\n\n<p>Ce diagramme de séquence illustre l'intégration des agents IA avec un environnement MCP sécurisé. Le processus commence quand un utilisateur accède à l'application IA, qui authentifie l'utilisateur avec le fournisseur d'identité et reçoit des jetons.</p>\n\n<p>Quand l'utilisateur fait une requête nécessitant des capacités IA, l'agent IA demande un jeton à l'application, qui le fournit. L'agent inclut ensuite ce jeton dans sa requête MCP à la passerelle API.</p>\n\n<p>La passerelle valide le jeton et applique les politiques de sécurité pour déterminer si la requête doit être autorisée. Si autorisée, la requête est transmise à l'outil MCP approprié, qui la traite et retourne une réponse. Cette réponse remonte à travers la passerelle vers l'agent et finalement vers l'utilisateur.</p>\n\n<p>En arrière-plan, l'application gère les cycles de rafraîchissement de jetons, demandant de nouveaux jetons d'accès au fournisseur d'identité quand nécessaire. Cela garantit une opération continue sans exiger que l'utilisateur se ré-authentifie fréquemment.</p>\n\n<p>Cette approche d'intégration garantit que les agents IA opèrent dans le cadre de sécurité établi par l'architecture proxy, avec toutes les requêtes correctement authentifiées et autorisées.</p>\n\n<h2>Conclusion : au-delà des appels API glorifiés</h2>\n\n<p>En implémentant une architecture MCP sécurisée avec un proxy conscient de l'identité, vous allez bien au-delà des « appels API glorifiés » vers une intégration robuste de qualité entreprise entre les agents IA et vos systèmes métier. Cette approche aborde les défis de sécurité clés des déploiements MCP, incluant :</p>\n\n<ul>\n<li>Identité utilisateur et contrôle d'accès</li>\n<li>Échanges de contexte multi-étapes</li>\n<li>Chaînes de délégation complexes</li>\n<li>Provisionnement dynamique d'outils</li>\n<li>Changements MCP distants et suivi de versions</li>\n</ul>\n\n<p>L'architecture basée sur proxy fournit un point de contrôle centralisé pour appliquer les politiques de sécurité, gérer l'accès aux outils et surveiller l'activité des agents IA. Elle simplifie également les opérations en abstrayant la complexité des services backend et en fournissant une interface cohérente pour les agents IA.</p>\n\n<p>Alors que MCP continue d'évoluer et de gagner en adoption, les patterns de sécurité décrits dans cet article deviendront de plus en plus importants pour les déploiements d'entreprise. En implémentant ces patterns maintenant, vous pouvez vous assurer que votre infrastructure d'agents IA est sécurisée, évolutive et prête pour l'avenir.</p>\n\n<pre><code class=\"language-mermaid\">graph LR\n    A[Appels API glorifiés] --&gt;|Évolution| B[Architecture MCP sécurisée]\n    \n    subgraph \"Avantages clés\"\n        C[Sécurité centralisée]\n        D[Propagation d'identité]\n        E[Application de politiques]\n        F[Audit &amp; conformité]\n        G[Simplicité opérationnelle]\n    end\n    \n    B --&gt; C\n    B --&gt; D\n    B --&gt; E\n    B --&gt; F\n    B --&gt; G\n    \n    classDef benefit fill:#bfb,stroke:#333,stroke-width:1px;\n    class C,D,E,F,G benefit;\n</code></pre>\n\n<p>Ce diagramme final résume l'évolution des « appels API glorifiés » vers une architecture MCP sécurisée, mettant en évidence les avantages clés de cette approche :</p>\n\n<ol>\n<li><strong>Sécurité centralisée</strong> : Un point de contrôle unique pour appliquer les politiques de sécurité à travers toutes les interactions MCP.</li>\n<li><strong>Propagation d'identité</strong> : Gestion cohérente de l'identité et des permissions utilisateur dans tout le système.</li>\n<li><strong>Application de politiques</strong> : Contrôle fin sur qui peut accéder à quels outils et sous quelles conditions.</li>\n<li><strong>Audit &amp; conformité</strong> : Journalisation et surveillance complètes de toutes les activités MCP à des fins de sécurité et de conformité.</li>\n<li><strong>Simplicité opérationnelle</strong> : Abstraction de la complexité backend, facilitant la gestion et l'évolution du système au fil du temps.</li>\n</ol>\n\n<p>En adoptant cette architecture, les organisations peuvent déployer en toute confiance des agents IA dans des environnements d'entreprise, sachant que leurs interactions MCP sont sécurisées, auditables et gérables à grande échelle. Cela représente une avancée significative au-delà de la vision simpliste des outils IA comme de simples appels API, reconnaissant les exigences de sécurité complexes des systèmes IA de production.</p>",
  "source_hash": "sha256:2e298f37ca328b0eb320a81887dd3640aeb212ad3bf1d820c547bb98ab9e3b19",
  "model": "claude-sonnet-4-5-20250929",
  "generated_at": "2026-01-02T03:19:29.693958+00:00"
}